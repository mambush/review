This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.gitignore
backend/.env
backend/.gitignore
backend/api/controllers/calendarController.js
backend/api/controllers/categoryController.js
backend/api/controllers/eventController.js
backend/api/controllers/notificationController.js
backend/api/controllers/recommendationController.js
backend/api/controllers/reviewController.js
backend/api/controllers/userController.js
backend/api/middleware/auth.js
backend/api/middleware/errorHandler.js
backend/api/middleware/validation.js
backend/api/models/calendarModel.js
backend/api/models/categoryModel.js
backend/api/models/eventModel.js
backend/api/models/notificationModel.js
backend/api/models/recommendationModel.js
backend/api/models/reviewModel.js
backend/api/models/userModel.js
backend/api/routes/calendar.js
backend/api/routes/categories.js
backend/api/routes/events.js
backend/api/routes/notifications.js
backend/api/routes/recommendations.js
backend/api/routes/reviews.js
backend/api/routes/users.js
backend/config/config.js
backend/config/database.js
backend/package.json
backend/server.js
backend/service/ai.service.js
backend/service/emailService.js
backend/service/uploadService.js
backend/utils/helpers.js
backend/utils/logger.js
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="backend/.gitignore">
.qodo
backend\node_modules
</file>

<file path="backend/api/middleware/errorHandler.js">
const { logger } = require('../../utils/logger');

/**
 * Global error handling middleware
 */
const errorHandler = (err, req, res, next) => {
  // Log the error
  logger.error(`${err.name}: ${err.message}`, { 
    method: req.method,
    url: req.url,
    body: req.body,
    stack: err.stack
  });

  // Error response object
  const error = {
    message: err.message || 'Server Error',
    status: err.statusCode || 500
  };

  // Add validation errors if available
  if (err.errors) {
    error.errors = err.errors;
  }

  // Add more detailed info in development
  if (process.env.NODE_ENV === 'development') {
    error.stack = err.stack;
  }

  res.status(error.status).json({
    success: false,
    error: error
  });
};

/**
 * Custom error class for API errors
 */
class ApiError extends Error {
  constructor(message, statusCode) {
    super(message);
    this.statusCode = statusCode;
    this.name = this.constructor.name;
    Error.captureStackTrace(this, this.constructor);
  }
}

/**
 * 404 Not Found error handler
 */
const notFound = (req, res, next) => {
  const error = new ApiError(`Not Found - ${req.originalUrl}`, 404);
  next(error);
};

module.exports = errorHandler;
module.exports.ApiError = ApiError;
module.exports.notFound = notFound;
</file>

<file path="backend/api/middleware/validation.js">
const { body, param, query, validationResult } = require('express-validator');
const { ApiError } = require('./errorHandler');

/**
 * Process validation results
 */
exports.validate = (req, res, next) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    const error = new ApiError('Validation error', 400);
    error.errors = errors.array().map(err => ({
      field: err.path,
      message: err.msg
    }));
    return next(error);
  }
  next();
};

/**
 * User validation rules
 */
exports.userRules = {
  // Create user validation
  createUser: [
    body('username')
      .trim()
      .isLength({ min: 3, max: 50 })
      .withMessage('Username must be between 3 and 50 characters'),
    body('email')
      .trim()
      .isEmail()
      .withMessage('Must be a valid email address'),
    body('password')
      .isLength({ min: 6 })
      .withMessage('Password must be at least 6 characters long')
  ],
  
  // Update user validation
  updateUser: [
    body('username')
      .optional()
      .trim()
      .isLength({ min: 3, max: 50 })
      .withMessage('Username must be between 3 and 50 characters'),
    body('email')
      .optional()
      .trim()
      .isEmail()
      .withMessage('Must be a valid email address'),
    body('bio')
      .optional()
      .isString()
      .withMessage('Bio must be a string')
  ],
  
  // Login validation
  login: [
    body('email')
      .trim()
      .isEmail()
      .withMessage('Must be a valid email address'),
    body('password')
      .exists()
      .withMessage('Password is required')
  ]
};

/**
 * Event validation rules
 */
exports.eventRules = {
  // Create event validation
  createEvent: [
    body('title')
      .trim()
      .isLength({ min: 5, max: 255 })
      .withMessage('Title must be between 5 and 255 characters'),
    body('description')
      .isString()
      .withMessage('Description must be a string')
      .isLength({ min: 10 })
      .withMessage('Description must be at least 10 characters'),
    body('date')
      .isDate()
      .withMessage('Date must be a valid date format (YYYY-MM-DD)'),
    body('time')
      .matches(/^([01]\d|2[0-3]):([0-5]\d)$/)
      .withMessage('Time must be in format HH:MM (24-hour)'),
    body('location')
      .trim()
      .isLength({ min: 5, max: 255 })
      .withMessage('Location must be between 5 and 255 characters'),
    body('categories')
      .isArray()
      .withMessage('Categories must be an array of category IDs')
  ],
  
  // Update event validation
  updateEvent: [
    body('title')
      .optional()
      .trim()
      .isLength({ min: 5, max: 255 })
      .withMessage('Title must be between 5 and 255 characters'),
    body('description')
      .optional()
      .isString()
      .withMessage('Description must be a string')
      .isLength({ min: 10 })
      .withMessage('Description must be at least 10 characters'),
    body('date')
      .optional()
      .isDate()
      .withMessage('Date must be a valid date format (YYYY-MM-DD)'),
    body('time')
      .optional()
      .matches(/^([01]\d|2[0-3]):([0-5]\d)$/)
      .withMessage('Time must be in format HH:MM (24-hour)'),
    body('location')
      .optional()
      .trim()
      .isLength({ min: 5, max: 255 })
      .withMessage('Location must be between 5 and 255 characters'),
    body('status')
      .optional()
      .isIn(['upcoming', 'ongoing', 'completed', 'cancelled'])
      .withMessage('Status must be one of: upcoming, ongoing, completed, cancelled'),
    body('categories')
      .optional()
      .isArray()
      .withMessage('Categories must be an array of category IDs')
  ]
};

/**
 * Review validation rules
 */
exports.reviewRules = {
  // Create review validation
  createReview: [
    body('event_id')
      .isInt({ min: 1 })
      .withMessage('Valid event ID is required'),
    body('rating')
      .isInt({ min: 1, max: 5 })
      .withMessage('Rating must be between 1 and 5'),
    body('content')
      .trim()
      .isLength({ min: 10 })
      .withMessage('Review content must be at least 10 characters')
  ],
  
  // Update review validation
  updateReview: [
    body('rating')
      .optional()
      .isInt({ min: 1, max: 5 })
      .withMessage('Rating must be between 1 and 5'),
    body('content')
      .optional()
      .trim()
      .isLength({ min: 10 })
      .withMessage('Review content must be at least 10 characters')
  ]
};

/**
 * Category validation rules
 */
exports.categoryRules = {
  // Create category validation
  createCategory: [
    body('name')
      .trim()
      .isLength({ min: 3, max: 100 })
      .withMessage('Category name must be between 3 and 100 characters'),
    body('description')
      .optional()
      .isString()
      .withMessage('Description must be a string')
  ],
  
  // Update category validation
  updateCategory: [
    body('name')
      .optional()
      .trim()
      .isLength({ min: 3, max: 100 })
      .withMessage('Category name must be between 3 and 100 characters'),
    body('description')
      .optional()
      .isString()
      .withMessage('Description must be a string')
  ]
};

/**
 * Calendar validation rules
 */
exports.calendarRules = {
  // Create calendar entry validation
  createCalendarEntry: [
    body('event_id')
      .isInt({ min: 1 })
      .withMessage('Valid event ID is required'),
    body('reminder_settings')
      .optional()
      .isJSON()
      .withMessage('Reminder settings must be valid JSON')
  ],
  
  // Update calendar entry validation
  updateCalendarEntry: [
    body('reminder_settings')
      .optional()
      .isJSON()
      .withMessage('Reminder settings must be valid JSON'),
    body('is_synced')
      .optional()
      .isBoolean()
      .withMessage('is_synced must be a boolean value')
  ]
};

/**
 * Common ID parameter validation
 */
exports.idParam = [
  param('id')
    .isInt({ min: 1 })
    .withMessage('ID parameter must be a positive integer')
];

/**
 * Pagination query parameters validation
 */
exports.paginationRules = [
  query('page')
    .optional()
    .isInt({ min: 1 })
    .withMessage('Page must be a positive integer'),
  query('limit')
    .optional()
    .isInt({ min: 1, max: 100 })
    .withMessage('Limit must be between 1 and 100')
];
</file>

<file path="backend/api/models/categoryModel.js">
// categoryModel.js
const db = require('../../config/database');

/**
 * Category model
 */
const Category = {
  /**
   * Create a new category
   * @param {Object} categoryData - Category data
   * @returns {Object} - Created category object
   */
  async create(categoryData) {
    try {
      // Insert category into database
      const result = await db.query(
        `INSERT INTO categories (name, description) VALUES (?, ?)`,
        [categoryData.name, categoryData.description || null]
      );

      // Get the created category
      const [category] = await this.findById(result.insertId);
      return category;
    } catch (error) {
      throw error;
    }
  },

  /**
   * Find category by ID
   * @param {number} id - Category ID
   * @returns {Object} - Category object
   */
  async findById(id) {
    return await db.query(
      `SELECT * FROM categories WHERE id = ?`,
      [id]
    );
  },

  /**
   * Find category by name
   * @param {string} name - Category name
   * @returns {Object} - Category object
   */
  async findByName(name) {
    return await db.query(
      `SELECT * FROM categories WHERE name = ?`,
      [name]
    );
  },

  /**
   * Update category
   * @param {number} id - Category ID
   * @param {Object} categoryData - Category data to update
   * @returns {Object} - Updated category object
   */
  async update(id, categoryData) {
    // Create dynamic update query based on provided fields
    const fields = [];
    const values = [];

    if (categoryData.name) {
      fields.push('name = ?');
      values.push(categoryData.name);
    }
    if (categoryData.description) {
      fields.push('description = ?');
      values.push(categoryData.description);
    }

    // Only proceed if there are fields to update
    if (fields.length === 0) {
      return await this.findById(id);
    }

    // Add ID to values array
    values.push(id);

    // Execute update query
    await db.query(
      `UPDATE categories SET ${fields.join(', ')} WHERE id = ?`,
      values
    );

    // Return updated category
    const [updatedCategory] = await this.findById(id);
    return updatedCategory;
  },

  /**
   * Delete category
   * @param {number} id - Category ID
   * @returns {boolean} - Success status
   */
  async delete(id) {
    const result = await db.query('DELETE FROM categories WHERE id = ?', [id]);
    return result.affectedRows > 0;
  },

  /**
   * Get all categories
   * @returns {Array} - Array of category objects
   */
  async getAll() {
    return await db.query('SELECT * FROM categories ORDER BY name ASC');
  },

  /**
   * Get categories with event count
   * @returns {Array} - Array of category objects with event count
   */
  async getAllWithEventCount() {
    return await db.query(
      `SELECT c.*, COUNT(ec.event_id) as event_count
       FROM categories c
       LEFT JOIN event_categories ec ON c.id = ec.category_id
       GROUP BY c.id
       ORDER BY c.name ASC`
    );
  },

  /**
   * Get popular categories
   * @param {number} limit - Number of categories to return
   * @returns {Array} - Array of popular category objects
   */
  async getPopular(limit = 5) {
    return await db.query(
      `SELECT c.*, COUNT(ec.event_id) as event_count
       FROM categories c
       JOIN event_categories ec ON c.id = ec.category_id
       GROUP BY c.id
       ORDER BY event_count DESC
       LIMIT ?`,
      [limit]
    );
  }
};

module.exports = Category;
</file>

<file path="backend/api/models/eventModel.js">
// eventModel.js
const db = require('../../config/database');

/**
 * Event model
 */
const Event = {
  /**
   * Create a new event
   * @param {Object} eventData - Event data
   * @returns {Object} - Created event object
   */
  async create(eventData) {
    try {
      // Insert event into database
      const result = await db.query(
        `INSERT INTO events (title, description, date, time, location, organizer_id, image, status) 
         VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
        [
          eventData.title,
          eventData.description,
          eventData.date,
          eventData.time,
          eventData.location,
          eventData.organizer_id,
          eventData.image || null,
          eventData.status || 'upcoming'
        ]
      );

      const eventId = result.insertId;

      // Add event categories if provided
      if (eventData.categories && eventData.categories.length > 0) {
        const categoryValues = eventData.categories.map(categoryId => [eventId, categoryId]);
        await db.query(
          `INSERT INTO event_categories (event_id, category_id) VALUES ?`,
          [categoryValues]
        );
      }

      // Get the created event
      const [event] = await this.findById(eventId);
      return event;
    } catch (error) {
      throw error;
    }
  },

  /**
   * Find event by ID
   * @param {number} id - Event ID
   * @returns {Object} - Event object
   */
  async findById(id) {
    const [event] = await db.query(
      `SELECT * FROM events WHERE id = ?`,
      [id]
    );
    
    if (event) {
      // Get event categories
      event.categories = await this.getEventCategories(id);
    }
    
    return event;
  },

  /**
   * Get event categories
   * @param {number} eventId - Event ID
   * @returns {Array} - Array of category objects
   */
  async getEventCategories(eventId) {
    return await db.query(
      `SELECT c.* FROM categories c
       JOIN event_categories ec ON c.id = ec.category_id
       WHERE ec.event_id = ?`,
      [eventId]
    );
  },

  /**
   * Update event
   * @param {number} id - Event ID
   * @param {Object} eventData - Event data to update
   * @returns {Object} - Updated event object
   */
  async update(id, eventData) {
    // Create dynamic update query based on provided fields
    const fields = [];
    const values = [];

    if (eventData.title) {
      fields.push('title = ?');
      values.push(eventData.title);
    }
    if (eventData.description) {
      fields.push('description = ?');
      values.push(eventData.description);
    }
    if (eventData.date) {
      fields.push('date = ?');
      values.push(eventData.date);
    }
    if (eventData.time) {
      fields.push('time = ?');
      values.push(eventData.time);
    }
    if (eventData.location) {
      fields.push('location = ?');
      values.push(eventData.location);
    }
    if (eventData.image) {
      fields.push('image = ?');
      values.push(eventData.image);
    }
    if (eventData.status) {
      fields.push('status = ?');
      values.push(eventData.status);
    }

    // Only proceed if there are fields to update
    if (fields.length === 0) {
      return await this.findById(id);
    }

    // Add ID to values array
    values.push(id);

    // Execute update query
    await db.query(
      `UPDATE events SET ${fields.join(', ')} WHERE id = ?`,
      values
    );

    // Update categories if provided
    if (eventData.categories && eventData.categories.length > 0) {
      // Remove existing categories
      await db.query('DELETE FROM event_categories WHERE event_id = ?', [id]);
      
      // Add new categories
      const categoryValues = eventData.categories.map(categoryId => [id, categoryId]);
      await db.query(
        `INSERT INTO event_categories (event_id, category_id) VALUES ?`,
        [categoryValues]
      );
    }

    // Return updated event
    const [updatedEvent] = await this.findById(id);
    return updatedEvent;
  },

  /**
   * Delete event
   * @param {number} id - Event ID
   * @returns {boolean} - Success status
   */
  async delete(id) {
    const result = await db.query('DELETE FROM events WHERE id = ?', [id]);
    return result.affectedRows > 0;
  },

  /**
   * Get all events
   * @param {Object} options - Query options (limit, offset, filter, sort)
   * @returns {Array} - Array of event objects
   */
  async getAll(options = { limit: 10, offset: 0, filter: {}, sort: { by: 'date', order: 'ASC' } }) {
    let query = `SELECT * FROM events`;
    const queryParams = [];
    
    // Add filter conditions
    if (options.filter) {
      const filterConditions = [];
      
      if (options.filter.status) {
        filterConditions.push('status = ?');
        queryParams.push(options.filter.status);
      }
      
      if (options.filter.organizer_id) {
        filterConditions.push('organizer_id = ?');
        queryParams.push(options.filter.organizer_id);
      }
      
      if (options.filter.dateFrom) {
        filterConditions.push('date >= ?');
        queryParams.push(options.filter.dateFrom);
      }
      
      if (options.filter.dateTo) {
        filterConditions.push('date <= ?');
        queryParams.push(options.filter.dateTo);
      }
      
      if (options.filter.search) {
        filterConditions.push('(title LIKE ? OR description LIKE ? OR location LIKE ?)');
        const searchTerm = `%${options.filter.search}%`;
        queryParams.push(searchTerm, searchTerm, searchTerm);
      }
      
      if (filterConditions.length > 0) {
        query += ` WHERE ${filterConditions.join(' AND ')}`;
      }
    }
    
    // Add sorting
    if (options.sort) {
      query += ` ORDER BY ${options.sort.by} ${options.sort.order}`;
    }
    
    // Add pagination
    query += ` LIMIT ? OFFSET ?`;
    queryParams.push(options.limit, options.offset);
    
    const events = await db.query(query, queryParams);
    
    // Get categories for each event
    for (const event of events) {
      event.categories = await this.getEventCategories(event.id);
    }
    
    return events;
  },

  /**
   * Get events by category
   * @param {number} categoryId - Category ID
   * @param {Object} options - Query options (limit, offset)
   * @returns {Array} - Array of event objects
   */
  async getByCategory(categoryId, options = { limit: 10, offset: 0 }) {
    const events = await db.query(
      `SELECT e.* FROM events e
       JOIN event_categories ec ON e.id = ec.event_id
       WHERE ec.category_id = ?
       ORDER BY e.date ASC
       LIMIT ? OFFSET ?`,
      [categoryId, options.limit, options.offset]
    );
    
    // Get categories for each event
    for (const event of events) {
      event.categories = await this.getEventCategories(event.id);
    }
    
    return events;
  },

  /**
   * Update event rating
   * @param {number} eventId - Event ID
   * @returns {boolean} - Success status
   */
  async updateRating(eventId) {
    const [ratingResult] = await db.query(
      `SELECT AVG(rating) as avg_rating FROM reviews WHERE event_id = ?`,
      [eventId]
    );
    
    if (ratingResult && ratingResult.avg_rating !== null) {
      await db.query(
        `UPDATE events SET avg_rating = ? WHERE id = ?`,
        [ratingResult.avg_rating, eventId]
      );
      return true;
    }
    return false;
  },

  /**
   * Count events
   * @param {Object} filter - Filter options
   * @returns {number} - Total number of events
   */
  async count(filter = {}) {
    let query = `SELECT COUNT(*) as total FROM events`;
    const queryParams = [];
    
    // Add filter conditions
    if (filter) {
      const filterConditions = [];
      
      if (filter.status) {
        filterConditions.push('status = ?');
        queryParams.push(filter.status);
      }
      
      if (filter.organizer_id) {
        filterConditions.push('organizer_id = ?');
        queryParams.push(filter.organizer_id);
      }
      
      if (filterConditions.length > 0) {
        query += ` WHERE ${filterConditions.join(' AND ')}`;
      }
    }
    
    const [result] = await db.query(query, queryParams);
    return result.total;
  }
};

module.exports = Event;
</file>

<file path="backend/api/models/notificationModel.js">
// notificationModel.js
const db = require('../../config/database');

/**
 * Notification model
 */
const Notification = {
  /**
   * Create a new notification
   * @param {Object} notificationData - Notification data
   * @returns {Object} - Created notification object
   */
  async create(notificationData) {
    try {
      // Insert notification into database
      const result = await db.query(
        `INSERT INTO notifications (user_id, content, type, related_id) VALUES (?, ?, ?, ?)`,
        [
          notificationData.user_id,
          notificationData.content,
          notificationData.type,
          notificationData.related_id || null
        ]
      );

      // Get the created notification
      const [notification] = await this.findById(result.insertId);
      return notification;
    } catch (error) {
      throw error;
    }
  },

  /**
   * Find notification by ID
   * @param {number} id - Notification ID
   * @returns {Object} - Notification object
   */
  async findById(id) {
    return await db.query(
      `SELECT * FROM notifications WHERE id = ?`,
      [id]
    );
  },

  /**
   * Mark notification as read
   * @param {number} id - Notification ID
   * @returns {boolean} - Success status
   */
  async markAsRead(id) {
    const result = await db.query(
      `UPDATE notifications SET read_status = TRUE WHERE id = ?`,
      [id]
    );
    
    return result.affectedRows > 0;
  },

  /**
   * Mark all user notifications as read
   * @param {number} userId - User ID
   * @returns {boolean} - Success status
   */
  async markAllAsRead(userId) {
    const result = await db.query(
      `UPDATE notifications SET read_status = TRUE WHERE user_id = ? AND read_status = FALSE`,
      [userId]
    );
    
    return result.affectedRows > 0;
  },

  /**
   * Delete notification
   * @param {number} id - Notification ID
   * @returns {boolean} - Success status
   */
  async delete(id) {
    const result = await db.query('DELETE FROM notifications WHERE id = ?', [id]);
    return result.affectedRows > 0;
  },

  /**
   * Get user notifications
   * @param {number} userId - User ID
   * @param {Object} options - Query options (limit, offset, unreadOnly)
   * @returns {Array} - Array of notification objects
   */
  async getUserNotifications(userId, options = { limit: 10, offset: 0, unreadOnly: false }) {
    let query = `SELECT * FROM notifications WHERE user_id = ?`;
    
    const queryParams = [userId];
    
    if (options.unreadOnly) {
      query += ' AND read_status = FALSE';
    }
    
    query += ' ORDER BY created_at DESC LIMIT ? OFFSET ?';
    queryParams.push(options.limit, options.offset);
    
    return await db.query(query, queryParams);
  },

  /**
   * Get unread notifications count
   * @param {number} userId - User ID
   * @returns {number} - Count of unread notifications
   */

  // notificationModel.js (continuation)
  /**
   * Get unread notifications count
   * @param {number} userId - User ID
   * @returns {number} - Count of unread notifications
   */
  async getUnreadCount(userId) {
    const [result] = await db.query(
      `SELECT COUNT(*) as count FROM notifications WHERE user_id = ? AND read_status = FALSE`,
      [userId]
    );
    
    return result.count;
  },

  /**
   * Create event notification for multiple users
   * @param {number} eventId - Event ID
   * @param {Array} userIds - Array of user IDs
   * @param {string} content - Notification content
   * @returns {number} - Number of notifications created
   */
  async createEventNotifications(eventId, userIds, content) {
    if (!userIds || userIds.length === 0) {
      return 0;
    }
    
    const values = userIds.map(userId => [userId, content, 'event', eventId]);
    
    const result = await db.query(
      `INSERT INTO notifications (user_id, content, type, related_id) VALUES ?`,
      [values]
    );
    
    return result.affectedRows;
  },

  /**
   * Create system notification for all users
   * @param {string} content - Notification content
   * @returns {number} - Number of notifications created
   */
  async createSystemNotificationForAll(content) {
    // Get all user IDs
    const users = await db.query('SELECT id FROM users');
    const userIds = users.map(user => user.id);
    
    if (userIds.length === 0) {
      return 0;
    }
    
    const values = userIds.map(userId => [userId, content, 'system', null]);
    
    const result = await db.query(
      `INSERT INTO notifications (user_id, content, type, related_id) VALUES ?`,
      [values]
    );
    
    return result.affectedRows;
  },

  /**
   * Delete old notifications
   * @param {number} days - Days to keep
   * @returns {number} - Number of notifications deleted
   */
  async deleteOldNotifications(days = 30) {
    const result = await db.query(
      `DELETE FROM notifications WHERE created_at < DATE_SUB(NOW(), INTERVAL ? DAY)`,
      [days]
    );
    
    return result.affectedRows;
  }
};

module.exports = Notification;
</file>

<file path="backend/api/models/recommendationModel.js">
// recommendationModel.js
const db = require('../../config/database');

/**
 * Recommendation model
 */
const Recommendation = {
  /**
   * Create or update a recommendation
   * @param {Object} recommendationData - Recommendation data
   * @returns {Object} - Created/updated recommendation object
   */
  async createOrUpdate(recommendationData) {
    try {
      // Check if recommendation already exists
      const [existingRecommendation] = await db.query(
        `SELECT id FROM recommendations WHERE user_id = ? AND event_id = ?`,
        [recommendationData.user_id, recommendationData.event_id]
      );

      let result;
      
      if (existingRecommendation) {
        // Update existing recommendation
        result = await db.query(
          `UPDATE recommendations SET score = ?, reason = ? WHERE id = ?`,
          [
            recommendationData.score,
            recommendationData.reason || null,
            existingRecommendation.id
          ]
        );
        
        // Get the updated recommendation
        const [updatedRecommendation] = await this.findById(existingRecommendation.id);
        return updatedRecommendation;
      } else {
        // Insert new recommendation
        result = await db.query(
          `INSERT INTO recommendations (user_id, event_id, score, reason) VALUES (?, ?, ?, ?)`,
          [
            recommendationData.user_id,
            recommendationData.event_id,
            recommendationData.score,
            recommendationData.reason || null
          ]
        );
        
        // Get the created recommendation
        const [newRecommendation] = await this.findById(result.insertId);
        return newRecommendation;
      }
    } catch (error) {
      throw error;
    }
  },

  /**
   * Find recommendation by ID
   * @param {number} id - Recommendation ID
   * @returns {Object} - Recommendation object
   */
  async findById(id) {
    return await db.query(
      `SELECT r.*, e.title as event_title, e.date as event_date
       FROM recommendations r
       JOIN events e ON r.event_id = e.id
       WHERE r.id = ?`,
      [id]
    );
  },

  /**
   * Delete recommendation
   * @param {number} id - Recommendation ID
   * @returns {boolean} - Success status
   */
  async delete(id) {
    const result = await db.query('DELETE FROM recommendations WHERE id = ?', [id]);
    return result.affectedRows > 0;
  },

  /**
   * Get user recommendations
   * @param {number} userId - User ID
   * @param {Object} options - Query options (limit, offset)
   * @returns {Array} - Array of recommendation objects
   */
  async getUserRecommendations(userId, options = { limit: 10, offset: 0 }) {
    return await db.query(
      `SELECT r.*, e.title, e.description, e.date, e.time, e.location, e.status, e.image
       FROM recommendations r
       JOIN events e ON r.event_id = e.id
       WHERE r.user_id = ? AND e.date >= CURDATE() AND e.status = 'upcoming'
       ORDER BY r.score DESC, e.date ASC
       LIMIT ? OFFSET ?`,
      [userId, options.limit, options.offset]
    );
  },

  /**
   * Generate recommendations for user
   * @param {number} userId - User ID
   * @returns {Array} - Array of recommendation objects
   * 
   * Note: This function would typically call an AI service or algorithm
   * to generate personalized recommendations. This implementation is a placeholder
   * that uses simple logic to recommend events.
   */
  async generateForUser(userId) {
    try {
      // Get user's past reviews and attended events
      const userReviews = await db.query(
        `SELECT r.event_id, r.rating, e.title, c.id as category_id
         FROM reviews r
         JOIN events e ON r.event_id = e.id
         JOIN event_categories ec ON e.id = ec.event_id
         JOIN categories c ON ec.category_id = c.id
         WHERE r.user_id = ?`,
        [userId]
      );
      
      // Get user's calendar events
      const userCalendar = await db.query(
        `SELECT c.event_id, e.title, ec.category_id
         FROM calendars c
         JOIN events e ON c.event_id = e.id
         JOIN event_categories ec ON e.id = ec.event_id
         WHERE c.user_id = ?`,
        [userId]
      );
      
      // Find categories the user is interested in
      const categoryInterest = {};
      
      userReviews.forEach(review => {
        if (!categoryInterest[review.category_id]) {
          categoryInterest[review.category_id] = 0;
        }
        categoryInterest[review.category_id] += review.rating;
      });
      
      userCalendar.forEach(event => {
        if (!categoryInterest[event.category_id]) {
          categoryInterest[event.category_id] = 0;
        }
        categoryInterest[event.category_id] += 3; // Attending an event shows interest
      });
      
      // Get upcoming events not already in user's calendar
      const upcomingEvents = await db.query(
        `SELECT e.id, e.title, e.date, e.time, e.location, e.status, ec.category_id, 
                e.avg_rating, COUNT(r.id) as review_count
         FROM events e
         JOIN event_categories ec ON e.id = ec.event_id
         LEFT JOIN reviews r ON e.id = r.event_id
         WHERE e.date >= CURDATE() 
         AND e.status = 'upcoming'
         AND e.id NOT IN (
           SELECT event_id FROM calendars WHERE user_id = ?
         )
         GROUP BY e.id, ec.category_id`,
        [userId]
      );
      
      // Score each event for the user
      const scoredEvents = {};
      
      upcomingEvents.forEach(event => {
        if (!scoredEvents[event.id]) {
          scoredEvents[event.id] = {
            event_id: event.id,
            title: event.title,
            score: 0,
            categories: []
          };
        }
        
        // Base score on category interest
        const categoryScore = categoryInterest[event.category_id] || 0;
        scoredEvents[event.id].score += categoryScore * 0.2;
        
        // Add category info
        scoredEvents[event.id].categories.push(event.category_id);
        
        // Factor in event popularity (review count and rating)
        scoredEvents[event.id].score += (event.avg_rating * 0.5) + (Math.min(event.review_count, 10) * 0.03);
      });
      
      // Convert to array and sort by score
      const recommendations = Object.values(scoredEvents)
        .map(item => ({
          user_id: userId,
          event_id: item.event_id,
          score: parseFloat(item.score.toFixed(4)),
          reason: `Based on your interest in events like "${item.title}"`
        }))
        .filter(item => item.score > 0)
        .sort((a, b) => b.score - a.score);
      
      // Save recommendations to database
      const savedRecommendations = [];
      
      for (const rec of recommendations.slice(0, 20)) { // Limit to top 20
        const saved = await this.createOrUpdate(rec);
        savedRecommendations.push(saved);
      }
      
      return savedRecommendations;
    } catch (error) {
      throw error;
    }
  },

  /**
   * Get popular events
   * @param {Object} options - Query options (limit, categoryId)
   * @returns {Array} - Array of popular event objects
   */
  async getPopularEvents(options = { limit: 10, categoryId: null }) {
    let query = `
      SELECT e.id, e.title, e.description, e.date, e.time, e.location, 
             e.image, e.avg_rating, COUNT(r.id) as review_count,
             COUNT(c.id) as calendar_count
      FROM events e
      LEFT JOIN reviews r ON e.id = r.event_id
      LEFT JOIN calendars c ON e.id = c.event_id
    `;
    
    const queryParams = [];
    
    if (options.categoryId) {
      query += `
        JOIN event_categories ec ON e.id = ec.event_id
        WHERE ec.category_id = ? AND e.date >= CURDATE() AND e.status = 'upcoming'
      `;
      queryParams.push(options.categoryId);
    } else {
      query += `
        WHERE e.date >= CURDATE() AND e.status = 'upcoming'
      `;
    }
    
    query += `
      GROUP BY e.id
      ORDER BY (e.avg_rating * 0.5) + (calendar_count * 0.3) + (review_count * 0.2) DESC
      LIMIT ?
    `;
    queryParams.push(options.limit);
    
    return await db.query(query, queryParams);
  },

  /**
   * Delete old recommendations
   * @param {number} days - Days to keep
   * @returns {number} - Number of recommendations deleted
   */
  async deleteOldRecommendations(days = 7) {
    const result = await db.query(
      `DELETE FROM recommendations WHERE created_at < DATE_SUB(NOW(), INTERVAL ? DAY)`,
      [days]
    );
    
    return result.affectedRows;
  }
};

module.exports = Recommendation;
</file>

<file path="backend/api/models/reviewModel.js">
// reviewModel.js
const db = require('../../config/database');
const Event = require('./eventModel');

/**
 * Review model
 */
const Review = {
  /**
   * Create a new review
   * @param {Object} reviewData - Review data
   * @returns {Object} - Created review object
   */
  async create(reviewData) {
    try {
      // Calculate sentiment (this would be integrated with a sentiment analysis service)
      let sentimentScore = null;
      let sentimentCategory = null;
      
      // If you have a sentiment analysis service, you would call it here
      // For now, we'll just assign a random score as a placeholder
      if (reviewData.content) {
        sentimentScore = Math.random() * 2 - 1; // Random score between -1 and 1
        
        if (sentimentScore > 0.3) {
          sentimentCategory = 'positive';
        } else if (sentimentScore < -0.3) {
          sentimentCategory = 'negative';
        } else {
          sentimentCategory = 'neutral';
        }
      }

      // Insert review into database
      const result = await db.query(
        `INSERT INTO reviews (user_id, event_id, rating, content, sentiment_score, sentiment_category) 
         VALUES (?, ?, ?, ?, ?, ?)`,
        [
          reviewData.user_id,
          reviewData.event_id,
          reviewData.rating,
          reviewData.content,
          sentimentScore,
          sentimentCategory
        ]
      );

      // Update event rating
      await Event.updateRating(reviewData.event_id);

      // Get the created review
      const [review] = await this.findById(result.insertId);
      return review;
    } catch (error) {
      throw error;
    }
  },

  /**
   * Find review by ID
   * @param {number} id - Review ID
   * @returns {Object} - Review object
   */
  async findById(id) {
    return await db.query(
      `SELECT r.*, u.username as user_name, e.title as event_title FROM reviews r
       JOIN users u ON r.user_id = u.id
       JOIN events e ON r.event_id = e.id
       WHERE r.id = ?`,
      [id]
    );
  },

  /**
   * Update review
   * @param {number} id - Review ID
   * @param {Object} reviewData - Review data to update
   * @returns {Object} - Updated review object
   */
  async update(id, reviewData) {
    // Get the current review to get the event_id
    const [currentReview] = await this.findById(id);
    if (!currentReview) {
      throw new Error('Review not found');
    }

    // Create dynamic update query based on provided fields
    const fields = [];
    const values = [];

    if (reviewData.rating) {
      fields.push('rating = ?');
      values.push(reviewData.rating);
    }
    
    if (reviewData.content) {
      fields.push('content = ?');
      values.push(reviewData.content);
      
      // Recalculate sentiment (this would be integrated with a sentiment analysis service)
      let sentimentScore = Math.random() * 2 - 1; // Random score between -1 and 1
      let sentimentCategory;
      
      if (sentimentScore > 0.3) {
        sentimentCategory = 'positive';
      } else if (sentimentScore < -0.3) {
        sentimentCategory = 'negative';
      } else {
        sentimentCategory = 'neutral';
      }
      
      fields.push('sentiment_score = ?');
      values.push(sentimentScore);
      fields.push('sentiment_category = ?');
      values.push(sentimentCategory);
    }

    // Only proceed if there are fields to update
    if (fields.length === 0) {
      return await this.findById(id);
    }

    // Add ID to values array
    values.push(id);

    // Execute update query
    await db.query(
      `UPDATE reviews SET ${fields.join(', ')} WHERE id = ?`,
      values
    );

    // Update event rating
    await Event.updateRating(currentReview.event_id);

    // Return updated review
    const [updatedReview] = await this.findById(id);
    return updatedReview;
  },

  /**
   * Delete review
   * @param {number} id - Review ID
   * @returns {boolean} - Success status
   */
  async delete(id) {
    // Get the current review to get the event_id
    const [currentReview] = await this.findById(id);
    if (!currentReview) {
      return false;
    }

    const result = await db.query('DELETE FROM reviews WHERE id = ?', [id]);
    
    // Update event rating
    if (result.affectedRows > 0) {
      await Event.updateRating(currentReview.event_id);
      return true;
    }
    
    return false;
  },

  /**
   * Get reviews by event
   * @param {number} eventId - Event ID
   * @param {Object} options - Query options (limit, offset)
   * @returns {Array} - Array of review objects
   */
  async getByEvent(eventId, options = { limit: 10, offset: 0 }) {
    return await db.query(
      `SELECT r.*, u.username as user_name FROM reviews r
       JOIN users u ON r.user_id = u.id
       WHERE r.event_id = ?
       ORDER BY r.created_at DESC
       LIMIT ? OFFSET ?`,
      [eventId, options.limit, options.offset]
    );
  },

  /**
   * Get reviews by user
   * @param {number} userId - User ID
   * @param {Object} options - Query options (limit, offset)
   * @returns {Array} - Array of review objects
   */
  async getByUser(userId, options = { limit: 10, offset: 0 }) {
    return await db.query(
      `SELECT r.*, e.title as event_title FROM reviews r
       JOIN events e ON r.event_id = e.id
       WHERE r.user_id = ?
       ORDER BY r.created_at DESC
       LIMIT ? OFFSET ?`,
      [userId, options.limit, options.offset]
    );
  },

  /**
   * Get review statistics
   * @param {number} eventId - Event ID
   * @returns {Object} - Review statistics
   */
  async getStats(eventId) {
    const [stats] = await db.query(
      `SELECT 
        COUNT(*) as total_reviews,
        AVG(rating) as avg_rating,
        SUM(CASE WHEN rating = 5 THEN 1 ELSE 0 END) as five_star,
        SUM(CASE WHEN rating = 4 THEN 1 ELSE 0 END) as four_star,
        SUM(CASE WHEN rating = 3 THEN 1 ELSE 0 END) as three_star,
        SUM(CASE WHEN rating = 2 THEN 1 ELSE 0 END) as two_star,
        SUM(CASE WHEN rating = 1 THEN 1 ELSE 0 END) as one_star,
        SUM(CASE WHEN sentiment_category = 'positive' THEN 1 ELSE 0 END) as positive_reviews,
        SUM(CASE WHEN sentiment_category = 'neutral' THEN 1 ELSE 0 END) as neutral_reviews,
        SUM(CASE WHEN sentiment_category = 'negative' THEN 1 ELSE 0 END) as negative_reviews
      FROM reviews
      WHERE event_id = ?`,
      [eventId]
    );
    
    return stats;
  }
};

module.exports = Review;
</file>

<file path="backend/api/models/userModel.js">
const db = require('../../config/database');
const bcrypt = require('bcryptjs');

/**
 * User model
 */
const User = {
  /**
   * Create a new user
   * @param {Object} userData - User data
   * @returns {Object} - Created user object
   */
  async create(userData) {
    try {
      // Hash password
      const salt = await bcrypt.genSalt(10);
      const hashedPassword = await bcrypt.hash(userData.password, salt);

      // Insert user into database
      const result = await db.query(
        `INSERT INTO users (username, email, password, bio, profile_pic) VALUES (?, ?, ?, ?, ?)`,
        [
          userData.username,
          userData.email,
          hashedPassword,
          userData.bio || null,
          userData.profile_pic || null
        ]
      );

      // Get the created user
      const [user] = await this.findById(result.insertId);
      return user;
    } catch (error) {
      throw error;
    }
  },

  /**
   * Find user by ID
   * @param {number} id - User ID
   * @returns {Array} - User object array
   */
  async findById(id) {
    return await db.query(
      `SELECT id, username, email, bio, profile_pic, is_admin, created_at, updated_at FROM users WHERE id = ?`,
      [id]
    );
  },

  /**
   * Find user by email (includes password for authentication)
   * @param {string} email - User email
   * @returns {Array} - User object array with password
   */
  async findByEmail(email) {
    return await db.query(
      `SELECT id, username, email, password, bio, profile_pic, is_admin, created_at, updated_at FROM users WHERE email = ?`,
      [email]
    );
  },

  /**
   * Find user by username
   * @param {string} username - Username
   * @returns {Array} - User object array
   */
  async findByUsername(username) {
    return await db.query(
      `SELECT id, username, email, bio, profile_pic, is_admin, created_at, updated_at FROM users WHERE username = ?`,
      [username]
    );
  },

  /**
   * Update user profile
   * @param {number} id - User ID
   * @param {Object} userData - User data to update
   * @returns {Object} - Updated user object
   */
  async update(id, userData) {
    // Create dynamic update query based on provided fields
    const fields = [];
    const values = [];

    if (userData.username) {
      fields.push('username = ?');
      values.push(userData.username);
    }
    if (userData.email) {
      fields.push('email = ?');
      values.push(userData.email);
    }
    if (userData.bio) {
      fields.push('bio = ?');
      values.push(userData.bio);
    }
    if (userData.profile_pic) {
      fields.push('profile_pic = ?');
      values.push(userData.profile_pic);
    }
    if (userData.password) {
      const salt = await bcrypt.genSalt(10);
      const hashedPassword = await bcrypt.hash(userData.password, salt);
      fields.push('password = ?');
      values.push(hashedPassword);
    }

    // Only proceed if there are fields to update
    if (fields.length === 0) {
      return await this.findById(id);
    }

    // Add ID to values array
    values.push(id);

    // Execute update query
    await db.query(
      `UPDATE users SET ${fields.join(', ')} WHERE id = ?`,
      values
    );

    // Return updated user
    const [updatedUser] = await this.findById(id);
    return updatedUser;
  },

  /**
   * Delete user
   * @param {number} id - User ID
   * @returns {boolean} - Success status
   */
  async delete(id) {
    const result = await db.query('DELETE FROM users WHERE id = ?', [id]);
    return result.affectedRows > 0;
  },

  /**
   * Get all users
   * @param {Object} options - Query options (limit, offset)
   * @returns {Array} - Array of user objects
   */
  async getAll(options = { limit: 10, offset: 0 }) {
    return await db.query(
      `SELECT id, username, email, bio, profile_pic, is_admin, created_at, updated_at 
       FROM users 
       ORDER BY created_at DESC 
       LIMIT ? OFFSET ?`,
      [options.limit, options.offset]
    );
  },

  /**
   * Change user role (admin/non-admin)
   * @param {number} id - User ID
   * @param {boolean} isAdmin - Admin status
   * @returns {Object} - Updated user object
   */
  async changeRole(id, isAdmin) {
    await db.query('UPDATE users SET is_admin = ? WHERE id = ?', [isAdmin, id]);
    const [updatedUser] = await this.findById(id);
    return updatedUser;
  },

  /**
   * Verify user password
   * @param {string} password - Plain password
   * @param {string} hashedPassword - Hashed password from database
   * @returns {boolean} - Password match status
   */
  async verifyPassword(password, hashedPassword) {
    return await bcrypt.compare(password, hashedPassword);
  },

  /**
   * Get user events
   * @param {number} userId - User ID
   * @param {string} type - Event type (organized, attended)
   * @returns {Array} - Array of event objects
   */
  async getUserEvents(userId, type = 'organized') {
    if (type === 'organized') {
      return await db.query(
        `SELECT e.* FROM events e
         WHERE e.organizer_id = ?
         ORDER BY e.date DESC`,
        [userId]
      );
    } else {
      return await db.query(
        `SELECT e.* FROM events e
         JOIN calendars c ON e.id = c.event_id
         WHERE c.user_id = ?
         ORDER BY e.date DESC`,
        [userId]
      );
    }
  },

  /**
   * Get user reviews
   * @param {number} userId - User ID
   * @returns {Array} - Array of review objects
   */
  async getUserReviews(userId) {
    return await db.query(
      `SELECT r.*, e.title as event_title FROM reviews r
       JOIN events e ON r.event_id = e.id
       WHERE r.user_id = ?
       ORDER BY r.created_at DESC`,
      [userId]
    );
  },

  /**
   * Count users
   * @returns {number} - Total number of users
   */
  async count() {
    const [result] = await db.query('SELECT COUNT(*) as total FROM users');
    return result.total;
  }
};

module.exports = User;
</file>

<file path="backend/config/config.js">
const dotenv = require('dotenv');

dotenv.config();

const config = {
  app: {
    port: process.env.PORT || 3000,
    env: process.env.NODE_ENV || 'development',
    jwtSecret: process.env.JWT_SECRET || '3d6f1a7e9c4b1e6e9f1a2c5b7d8e3a9f1c4b6d7e9f1a3b5c6d7e8f9a2b3c4d6',
    jwtExpiresIn: process.env.JWT_EXPIRES_IN || '24h'
  },
  db: {
    host: process.env.DB_HOST || 'localhost',
    user: process.env.DB_USER || 'root',
    password: process.env.DB_PASS || '',
    database: process.env.DB_NAME || 'eventreviews'
  },
  claude: {
    apiKey: process.env.CLAUDE_API_KEY,
    apiUrl: process.env.CLAUDE_API_URL || 'https://api.anthropic.com/v1/messages'
  },
  upload: {
    path: process.env.UPLOAD_PATH || './uploads',
    maxFileSize: parseInt(process.env.MAX_FILE_SIZE) || 5 * 1024 * 1024 // 5MB
  },
  email: {
    host: process.env.EMAIL_HOST,
    port: parseInt(process.env.EMAIL_PORT) || 587,
    user: process.env.EMAIL_USER,
    pass: process.env.EMAIL_PASS
  }
};

module.exports = config;
</file>

<file path="backend/utils/helpers.js">
/**
 * Collection of helper functions for the application
 */

/**
 * Formats a date to YYYY-MM-DD format
 * @param {Date} date - Date object
 * @returns {string} - Formatted date string
 */
const formatDate = (date) => {
    return date.toISOString().split('T')[0];
  };
  
  /**
   * Generates a random string for various purposes
   * @param {number} length - Length of the string
   * @returns {string} - Random string
   */
  const generateRandomString = (length = 10) => {
    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    let result = '';
    for (let i = 0; i < length; i++) {
      result += characters.charAt(Math.floor(Math.random() * characters.length));
    }
    return result;
  };
  
  /**
   * Paginates an array of results
   * @param {Array} array - The array to paginate
   * @param {number} page - The page number
   * @param {number} limit - Items per page
   * @returns {Object} - Paginated results
   */
  const paginate = (array, page = 1, limit = 10) => {
    const startIndex = (page - 1) * limit;
    const endIndex = page * limit;
    const results = {};
  
    if (endIndex < array.length) {
      results.next = {
        page: page + 1,
        limit
      };
    }
  
    if (startIndex > 0) {
      results.previous = {
        page: page - 1,
        limit
      };
    }
  
    results.totalPages = Math.ceil(array.length / limit);
    results.currentPage = page;
    results.totalItems = array.length;
    results.results = array.slice(startIndex, endIndex);
  
    return results;
  };
  
  /**
   * Validates if a string is a valid email
   * @param {string} email - Email to validate
   * @returns {boolean} - Is valid email
   */
  const isValidEmail = (email) => {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  };
  
  /**
   * Removes sensitive fields from user object
   * @param {Object} user - User object
   * @returns {Object} - Sanitized user object
   */
   const sanitizeUser = (user) => {
    if (!user) return null;
    
    const { password, ...sanitizedUser } = user;
    return sanitizedUser;
  };
  
  /**
   * Escapes special characters in strings for SQL queries
   * @param {string} text - Input text
   * @returns {string} - Escaped text
   */
  const escapeSQL = (text) => {
    if (typeof text !== 'string') return text;
    
    return text
      .replace(/\\/g, '\\\\')
      .replace(/'/g, "\\'")
      .replace(/"/g, '\\"')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/\t/g, '\\t')
      .replace(/\0/g, '\\0');
  };
  
  module.exports = {
    formatDate,
    generateRandomString,
    paginate,
    isValidEmail,
    sanitizeUser,
    escapeSQL
  };
</file>

<file path="README.md">
# review
</file>

<file path="backend/.env">
# Server configuration
PORT=5000
NODE_ENV=development

# Database configuration
DB_HOST=localhost
DB_USER=root
DB_PASSWORD=Nyandana@23!
DB_NAME=eventreviews

# JWT configuration
JWT_SECRET=your_jwt_secret_here
JWT_EXPIRES_IN=30d

# File upload configuration
UPLOAD_DIR=uploads

# Logging configuration
LOG_LEVEL=info

# Claude AI API Configuration
CLAUDE_API_KEY=your_claude_api_key
CLAUDE_API_URL=https://api.anthropic.com/v1/messages

# File Upload Configuration
UPLOAD_PATH=./uploads
MAX_FILE_SIZE=5242880

# Email Configuration
EMAIL_HOST=smtp.example.com
EMAIL_PORT=587
EMAIL_USER=siphelosp2nyands@gmail.com
EMAIL_PASS=Nyandana@23!
</file>

<file path="backend/api/controllers/calendarController.js">
const db = require('../../config/database');
const logger = require('../../utils/logger');

/**
 * Get all calendar entries for a user
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
exports.getUserCalendarEntries = async (req, res) => {
  try {
    const userId = req.user.id;
    
    const query = `
      SELECT c.*, e.title, e.description, e.date, e.time, e.location, e.status
      FROM calendars c
      JOIN events e ON c.event_id = e.id
      WHERE c.user_id = ?
      ORDER BY e.date, e.time
    `;
    
    const [entries] = await db.query(query, [userId]);
    
    return res.status(200).json({
      success: true,
      count: entries.length,
      data: entries
    });
  } catch (error) {
    logger.error(`Error getting user calendar entries: ${error.message}`);
    return res.status(500).json({
      success: false,
      message: 'Server Error'
    });
  }
};

/**
 * Add an event to user's calendar
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
exports.addToCalendar = async (req, res) => {
  try {
    const userId = req.user.id;
    const { event_id, reminder_settings, is_synced } = req.body;
    
    if (!event_id) {
      return res.status(400).json({
        success: false,
        message: 'Please provide event ID'
      });
    }
    
    // Check if event exists
    const [event] = await db.query('SELECT * FROM events WHERE id = ?', [event_id]);
    
    if (event.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'Event not found'
      });
    }
    
    // Check if already added to calendar
    const [existing] = await db.query(
      'SELECT * FROM calendars WHERE user_id = ? AND event_id = ?',
      [userId, event_id]
    );
    
    if (existing.length > 0) {
      return res.status(400).json({
        success: false,
        message: 'Event already added to calendar'
      });
    }
    
    // Default reminder settings if not provided
    const defaultReminderSettings = JSON.stringify({
      remind: true,
      time: 60, // minutes before event
      method: "email"
    });
    
    const reminderJSON = reminder_settings 
      ? JSON.stringify(reminder_settings) 
      : defaultReminderSettings;
    
    const syncStatus = is_synced !== undefined ? is_synced : false;
    
    const query = `
      INSERT INTO calendars (user_id, event_id, reminder_settings, is_synced)
      VALUES (?, ?, ?, ?)
    `;
    
    const [result] = await db.query(query, [
      userId, 
      event_id, 
      reminderJSON, 
      syncStatus
    ]);
    
    if (result.affectedRows === 0) {
      return res.status(400).json({
        success: false,
        message: 'Could not add event to calendar'
      });
    }
    
    const [newEntry] = await db.query(
      'SELECT * FROM calendars WHERE id = ?',
      [result.insertId]
    );
    
    return res.status(201).json({
      success: true,
      data: newEntry[0]
    });
  } catch (error) {
    logger.error(`Error adding event to calendar: ${error.message}`);
    return res.status(500).json({
      success: false,
      message: 'Server Error'
    });
  }
};

/**
 * Update calendar entry reminder settings
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
exports.updateReminderSettings = async (req, res) => {
  try {
    const calendarId = req.params.id;
    const userId = req.user.id;
    const { reminder_settings } = req.body;
    
    if (!reminder_settings) {
      return res.status(400).json({
        success: false,
        message: 'Please provide reminder settings'
      });
    }
    
    // Verify calendar entry belongs to user
    const [entry] = await db.query(
      'SELECT * FROM calendars WHERE id = ? AND user_id = ?',
      [calendarId, userId]
    );
    
    if (entry.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'Calendar entry not found or does not belong to user'
      });
    }
    
    const reminderJSON = JSON.stringify(reminder_settings);
    
    const query = `
      UPDATE calendars
      SET reminder_settings = ?
      WHERE id = ?
    `;
    
    await db.query(query, [reminderJSON, calendarId]);
    
    const [updated] = await db.query(
      'SELECT * FROM calendars WHERE id = ?',
      [calendarId]
    );
    
    return res.status(200).json({
      success: true,
      data: updated[0]
    });
  } catch (error) {
    logger.error(`Error updating reminder settings: ${error.message}`);
    return res.status(500).json({
      success: false,
      message: 'Server Error'
    });
  }
};

/**
 * Update sync status of calendar entry
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
exports.updateSyncStatus = async (req, res) => {
  try {
    const calendarId = req.params.id;
    const userId = req.user.id;
    const { is_synced } = req.body;
    
    if (is_synced === undefined) {
      return res.status(400).json({
        success: false,
        message: 'Please provide sync status'
      });
    }
    
    // Verify calendar entry belongs to user
    const [entry] = await db.query(
      'SELECT * FROM calendars WHERE id = ? AND user_id = ?',
      [calendarId, userId]
    );
    
    if (entry.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'Calendar entry not found or does not belong to user'
      });
    }
    
    const query = `
      UPDATE calendars
      SET is_synced = ?
      WHERE id = ?
    `;
    
    await db.query(query, [is_synced, calendarId]);
    
    return res.status(200).json({
      success: true,
      message: `Calendar entry sync status updated to ${is_synced}`
    });
  } catch (error) {
    logger.error(`Error updating sync status: ${error.message}`);
    return res.status(500).json({
      success: false,
      message: 'Server Error'
    });
  }
};

/**
 * Remove event from user's calendar
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
exports.removeFromCalendar = async (req, res) => {
  try {
    const calendarId = req.params.id;
    const userId = req.user.id;
    
    // Verify calendar entry belongs to user
    const [entry] = await db.query(
      'SELECT * FROM calendars WHERE id = ? AND user_id = ?',
      [calendarId, userId]
    );
    
    if (entry.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'Calendar entry not found or does not belong to user'
      });
    }
    
    await db.query('DELETE FROM calendars WHERE id = ?', [calendarId]);
    
    return res.status(200).json({
      success: true,
      message: 'Event removed from calendar'
    });
  } catch (error) {
    logger.error(`Error removing event from calendar: ${error.message}`);
    return res.status(500).json({
      success: false,
      message: 'Server Error'
    });
  }
};

/**
 * Get upcoming events from user's calendar
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
exports.getUpcomingEvents = async (req, res) => {
  try {
    const userId = req.user.id;
    const { days = 7 } = req.query; // Default to 7 days ahead
    
    const query = `
      SELECT c.*, e.title, e.description, e.date, e.time, e.location, e.status
      FROM calendars c
      JOIN events e ON c.event_id = e.id
      WHERE c.user_id = ? 
      AND e.date BETWEEN CURDATE() AND DATE_ADD(CURDATE(), INTERVAL ? DAY)
      ORDER BY e.date, e.time
    `;
    
    const [events] = await db.query(query, [userId, parseInt(days)]);
    
    return res.status(200).json({
      success: true,
      count: events.length,
      data: events
    });
  } catch (error) {
    logger.error(`Error getting upcoming events: ${error.message}`);
    return res.status(500).json({
      success: false,
      message: 'Server Error'
    });
  }
};
</file>

<file path="backend/api/controllers/categoryController.js">
const db = require('../../config/database');

exports.createCategory = async (req, res) => {
  try {
    // Only admins can create categories
    if (!req.user.isAdmin) {
      return res.status(403).json({ message: 'Access denied' });
    }
    
    const { name, description } = req.body;
    
    // Check if category already exists
    const [existingCategories] = await db.query(
      'SELECT * FROM categories WHERE name = ?',
      [name]
    );
    
    if (existingCategories.length > 0) {
      return res.status(400).json({ message: 'Category already exists' });
    }
    
    // Insert new category
    const [result] = await db.query(
      'INSERT INTO categories (name, description) VALUES (?, ?)',
      [name, description || null]
    );
    
    res.status(201).json({
      id: result.insertId,
      name,
      description,
      message: 'Category created successfully'
    });
  } catch (error) {
    console.error('Create category error:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

exports.getAllCategories = async (req, res) => {
  try {
    // Get query parameters
    const { search, sort = 'name', order = 'asc' } = req.query;
    
    let query = 'SELECT * FROM categories';
    let params = [];
    
    // Add search filter if provided
    if (search) {
      query += ' WHERE name LIKE ? OR description LIKE ?';
      const searchParam = `%${search}%`;
      params.push(searchParam, searchParam);
    }
    
    // Add sorting
    const validSortFields = ['name', 'created_at'];
    const validOrders = ['asc', 'desc'];
    
    const sortField = validSortFields.includes(sort) ? sort : 'name';
    const sortOrder = validOrders.includes(order.toLowerCase()) ? order : 'asc';
    
    query += ` ORDER BY ${sortField} ${sortOrder}`;
    
    // Execute query
    const [categories] = await db.query(query, params);
    
    // Get event count for each category
    for (const category of categories) {
      const [countResult] = await db.query(`
        SELECT COUNT(*) as event_count
        FROM event_categories
        WHERE category_id = ?
      `, [category.id]);
      
      category.eventCount = countResult[0].event_count;
    }
    
    res.json(categories);
  } catch (error) {
    console.error('Get all categories error:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

exports.getCategoryById = async (req, res) => {
  try {
    const { id } = req.params;
    
    // Get category
    const [categories] = await db.query('SELECT * FROM categories WHERE id = ?', [id]);
    
    if (categories.length === 0) {
      return res.status(404).json({ message: 'Category not found' });
    }
    
    const category = categories[0];
    
    // Get event count for category
    const [countResult] = await db.query(
      'SELECT COUNT(*) as event_count FROM event_categories WHERE category_id = ?',
      [id]
    );
    
    category.eventCount = countResult[0].event_count;
    
    res.json(category);
  } catch (error) {
    console.error('Get category error:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

exports.updateCategory = async (req, res) => {
  try {
    // Only admins can update categories
    if (!req.user.isAdmin) {
      return res.status(403).json({ message: 'Access denied' });
    }
    
    const { id } = req.params;
    const { name, description } = req.body;
    
    // Check if category exists
    const [categories] = await db.query('SELECT * FROM categories WHERE id = ?', [id]);
    
    if (categories.length === 0) {
      return res.status(404).json({ message: 'Category not found' });
    }
    
    // Check if name already exists for another category
    if (name) {
      const [existingCategories] = await db.query(
        'SELECT * FROM categories WHERE name = ? AND id != ?',
        [name, id]
      );
      
      if (existingCategories.length > 0) {
        return res.status(400).json({ message: 'Category name already exists' });
      }
    }
    
    // Construct update query dynamically
    let updateFields = [];
    let queryParams = [];
    
    if (name) {
      updateFields.push('name = ?');
      queryParams.push(name);
    }
    
    if (description !== undefined) {
      updateFields.push('description = ?');
      queryParams.push(description);
    }
    
    if (updateFields.length === 0) {
      return res.status(400).json({ message: 'No fields to update' });
    }
    
    // Add category ID to params
    queryParams.push(id);
    
    const query = `UPDATE categories SET ${updateFields.join(', ')} WHERE id = ?`;
    
    await db.query(query, queryParams);
    
    res.json({ message: 'Category updated successfully' });
  } catch (error) {
    console.error('Update category error:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

exports.deleteCategory = async (req, res) => {
  try {
    // Only admins can delete categories
    if (!req.user.isAdmin) {
      return res.status(403).json({ message: 'Access denied' });
    }
    
    const { id } = req.params;
    
    // Check if category exists
    const [categories] = await db.query('SELECT * FROM categories WHERE id = ?', [id]);
    
    if (categories.length === 0) {
      return res.status(404).json({ message: 'Category not found' });
    }
    
    // Delete category - cascade will handle related records
    await db.query('DELETE FROM categories WHERE id = ?', [id]);
    
    res.json({ message: 'Category deleted successfully' });
  } catch (error) {
    console.error('Delete category error:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

exports.getCategoryEvents = async (req, res) => {
  try {
    const { id } = req.params;
    const { page = 1, limit = 10, status } = req.query;
    
    // Check if category exists
    const [categories] = await db.query('SELECT * FROM categories WHERE id = ?', [id]);
    
    if (categories.length === 0) {
      return res.status(404).json({ message: 'Category not found' });
    }
    
    // Calculate offset for pagination
    const offset = (page - 1) * limit;
    
    // Build query
    let query = `
      SELECT e.*, u.username as organizer_name
      FROM events e
      JOIN event_categories ec ON e.id = ec.event_id
      JOIN users u ON e.organizer_id = u.id
      WHERE ec.category_id = ?
    `;
    
    let countQuery = `
      SELECT COUNT(*) as total
      FROM events e
      JOIN event_categories ec ON e.id = ec.event_id
      WHERE ec.category_id = ?
    `;
    
    const queryParams = [id];
    
    // Add status filter if provided
    if (status) {
      query += ' AND e.status = ?';
      countQuery += ' AND e.status = ?';
      queryParams.push(status);
    }
    
    // Add sorting and pagination
    query += ' ORDER BY e.date DESC LIMIT ? OFFSET ?';
    queryParams.push(parseInt(limit), parseInt(offset));
    
    // Execute queries
    const [events] = await db.query(query, queryParams);
    const [countResult] = await db.query(countQuery, queryParams.slice(0, status ? 2 : 1));
    
    const total = countResult[0].total;
    
    res.json({
      events,
      pagination: {
        total,
        page: parseInt(page),
        pageSize: parseInt(limit),
        totalPages: Math.ceil(total / limit)
      }
    });
  } catch (error) {
    console.error('Get category events error:', error);
    res.status(500).json({ message: 'Server error' });
  }
};
</file>

<file path="backend/api/controllers/eventController.js">
const db = require('../../config/database');

exports.createEvent = async (req, res) => {
  try {
    const { title, description, date, time, location, categoryIds } = req.body;
    const organizerId = req.user.id;
    let image = null;
    
    // If there's an image upload, get the path
    if (req.file) {
      image = req.file.path;
    }
    
    const connection = await db.getConnection();
    
    try {
      await connection.beginTransaction();
      
      // Insert event
      const [eventResult] = await connection.query(
        'INSERT INTO events (title, description, date, time, location, organizer_id, image) VALUES (?, ?, ?, ?, ?, ?, ?)',
        [title, description, date, time, location, organizerId, image]
      );
      
      const eventId = eventResult.insertId;
      
      // Insert event categories if provided
      if (categoryIds && Array.isArray(categoryIds) && categoryIds.length > 0) {
        const categoryValues = categoryIds.map(categoryId => [eventId, categoryId]);
        await connection.query(
          'INSERT INTO event_categories (event_id, category_id) VALUES ?',
          [categoryValues]
        );
      }
      
      await connection.commit();
      
      res.status(201).json({
        id: eventId,
        title,
        description,
        date,
        time,
        location,
        organizerId,
        image,
        status: 'upcoming',
        avgRating: 0,
        message: 'Event created successfully'
      });
    } catch (error) {
      await connection.rollback();
      throw error;
    } finally {
      connection.release();
    }
  } catch (error) {
    console.error('Create event error:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

exports.getAllEvents = async (req, res) => {
  try {
    const { 
      category, 
      status, 
      organizer, 
      search,
      sortBy = 'date', 
      sortDir = 'asc',
      page = 1,
      limit = 10
    } = req.query;
    
    let query = `
      SELECT e.*, u.username as organizer_name
      FROM events e
      JOIN users u ON e.organizer_id = u.id
    `;
    
    let countQuery = 'SELECT COUNT(*) as total FROM events e';
    let whereConditions = [];
    let params = [];
    
    // Add category filter if provided
    if (category) {
      query += ' JOIN event_categories ec ON e.id = ec.event_id';
      countQuery += ' JOIN event_categories ec ON e.id = ec.event_id';
      whereConditions.push('ec.category_id = ?');
      params.push(category);
    }
    
    // Add status filter if provided
    if (status) {
      whereConditions.push('e.status = ?');
      params.push(status);
    }
    
    // Add organizer filter if provided
    if (organizer) {
      whereConditions.push('e.organizer_id = ?');
      params.push(organizer);
    }
    
    // Add search filter if provided
    if (search) {
      whereConditions.push('(e.title LIKE ? OR e.description LIKE ? OR e.location LIKE ?)');
      const searchParam = `%${search}%`;
      params.push(searchParam, searchParam, searchParam);
    }
    
    // Add WHERE clause if conditions exist
    if (whereConditions.length > 0) {
      query += ' WHERE ' + whereConditions.join(' AND ');
      countQuery += ' WHERE ' + whereConditions.join(' AND ');
    }
    
    // Add GROUP BY to handle joins causing duplicate rows
    query += ' GROUP BY e.id';
    
    // Add sorting
    const validSortFields = ['date', 'title', 'avg_rating', 'created_at'];
    const validSortDirs = ['asc', 'desc'];
    
    const sortField = validSortFields.includes(sortBy) ? sortBy : 'date';
    const sortDirection = validSortDirs.includes(sortDir.toLowerCase()) ? sortDir : 'asc';
    
    query += ` ORDER BY e.${sortField} ${sortDirection}`;
    
    // Add pagination
    const offset = (page - 1) * limit;
    query += ' LIMIT ? OFFSET ?';
    params.push(parseInt(limit), parseInt(offset));
    
    // Execute queries
    const [events] = await db.query(query, params);
    const [countResult] = await db.query(countQuery, params.slice(0, params.length - 2));
    
    // Get categories for each event
    for (const event of events) {
      const [categories] = await db.query(`
        SELECT c.id, c.name
        FROM categories c
        JOIN event_categories ec ON c.id = ec.category_id
        WHERE ec.event_id = ?
      `, [event.id]);
      
      event.categories = categories;
    }
    
    const total = countResult[0].total;
    
    res.json({
      events,
      pagination: {
        total,
        page: parseInt(page),
        pageSize: parseInt(limit),
        totalPages: Math.ceil(total / limit)
      }
    });
  } catch (error) {
    console.error('Get all events error:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

exports.getEventById = async (req, res) => {
  try {
    const { id } = req.params;
    
    // Get event details
    const [events] = await db.query(`
      SELECT e.*, u.username as organizer_name
      FROM events e
      JOIN users u ON e.organizer_id = u.id
      WHERE e.id = ?
    `, [id]);
    
    if (events.length === 0) {
      return res.status(404).json({ message: 'Event not found' });
    }
    
    const event = events[0];
    
    // Get event categories
    const [categories] = await db.query(`
      SELECT c.id, c.name
      FROM categories c
      JOIN event_categories ec ON c.id = ec.category_id
      WHERE ec.event_id = ?
    `, [id]);
    
    event.categories = categories;
    
    // Get review stats
    const [reviewStats] = await db.query(`
      SELECT 
        COUNT(*) as total_reviews,
        AVG(rating) as average_rating,
        COUNT(CASE WHEN sentiment_category = 'positive' THEN 1 END) as positive_reviews,
        COUNT(CASE WHEN sentiment_category = 'neutral' THEN 1 END) as neutral_reviews,
        COUNT(CASE WHEN sentiment_category = 'negative' THEN 1 END) as negative_reviews
      FROM reviews
      WHERE event_id = ?
    `, [id]);
    
    event.reviewStats = reviewStats[0];
    
    res.json(event);
  } catch (error) {
    console.error('Get event error:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

exports.updateEvent = async (req, res) => {
  try {
    const { id } = req.params;
    const { title, description, date, time, location, status, categoryIds } = req.body;
    let image = null;
    
    // If there's an image upload, get the path
    if (req.file) {
      image = req.file.path;
    }
    
    // Check if event exists and user is organizer or admin
    const [events] = await db.query('SELECT * FROM events WHERE id = ?', [id]);
    
    if (events.length === 0) {
      return res.status(404).json({ message: 'Event not found' });
    }
    
    if (events[0].organizer_id !== req.user.id && !req.user.isAdmin) {
      return res.status(403).json({ message: 'Not authorized to update this event' });
    }
    
    const connection = await db.getConnection();
    
    try {
      await connection.beginTransaction();
      
      // Construct update query dynamically
      let updateFields = [];
      let queryParams = [];
      
      if (title) {
        updateFields.push('title = ?');
        queryParams.push(title);
      }
      
      if (description !== undefined) {
        updateFields.push('description = ?');
        queryParams.push(description);
      }
      
      if (date) {
        updateFields.push('date = ?');
        queryParams.push(date);
      }
      
      if (time) {
        updateFields.push('time = ?');
        queryParams.push(time);
      }
      
      if (location) {
        updateFields.push('location = ?');
        queryParams.push(location);
      }
      
      if (status) {
        updateFields.push('status = ?');
        queryParams.push(status);
      }
      
      if (image) {
        updateFields.push('image = ?');
        queryParams.push(image);
      }
      
      if (updateFields.length > 0) {
        // Add event ID to params
        queryParams.push(id);
        
        const query = `UPDATE events SET ${updateFields.join(', ')} WHERE id = ?`;
        await connection.query(query, queryParams);
      }
      
      // Update categories if provided
      if (categoryIds && Array.isArray(categoryIds)) {
        // Delete existing categories
        await connection.query('DELETE FROM event_categories WHERE event_id = ?', [id]);
        
        // Insert new categories
        if (categoryIds.length > 0) {
          const categoryValues = categoryIds.map(categoryId => [id, categoryId]);
          await connection.query(
            'INSERT INTO event_categories (event_id, category_id) VALUES ?',
            [categoryValues]
          );
        }
      }
      
      await connection.commit();
      
      res.json({ message: 'Event updated successfully' });
    } catch (error) {
      await connection.rollback();
      throw error;
    } finally {
      connection.release();
    }
  } catch (error) {
    console.error('Update event error:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

exports.deleteEvent = async (req, res) => {
  try {
    const { id } = req.params;
    
    // Check if event exists and user is organizer or admin
    const [events] = await db.query('SELECT * FROM events WHERE id = ?', [id]);
    
    if (events.length === 0) {
      return res.status(404).json({ message: 'Event not found' });
    }
    
    if (events[0].organizer_id !== req.user.id && !req.user.isAdmin) {
      return res.status(403).json({ message: 'Not authorized to delete this event' });
    }
    
    // Delete event - cascade will handle related records
    await db.query('DELETE FROM events WHERE id = ?', [id]);
    
    res.json({ message: 'Event deleted successfully' });
  } catch (error) {
    console.error('Delete event error:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

exports.getUserEvents = async (req, res) => {
  try {
    const userId = req.params.userId || req.user.id;
    
    const [events] = await db.query(`
      SELECT e.*, u.username as organizer_name
      FROM events e
      JOIN users u ON e.organizer_id = u.id
      WHERE e.organizer_id = ?
      ORDER BY e.date DESC
    `, [userId]);
    
    // Get categories for each event
    for (const event of events) {
      const [categories] = await db.query(`
        SELECT c.id, c.name
        FROM categories c
        JOIN event_categories ec ON c.id = ec.category_id
        WHERE ec.event_id = ?
      `, [event.id]);
      
      event.categories = categories;
    }
    
    res.json(events);
  } catch (error) {
    console.error('Get user events error:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

exports.updateEventStatus = async (req, res) => {
  try {
    const { id } = req.params;
    const { status } = req.body;
    
    if (!['upcoming', 'ongoing', 'completed', 'cancelled'].includes(status)) {
      return res.status(400).json({ message: 'Invalid status' });
    }
    
    // Check if event exists and user is organizer or admin
    const [events] = await db.query('SELECT * FROM events WHERE id = ?', [id]);
    
    if (events.length === 0) {
      return res.status(404).json({ message: 'Event not found' });
    }
    
    if (events[0].organizer_id !== req.user.id && !req.user.isAdmin) {
      return res.status(403).json({ message: 'Not authorized to update this event' });
    }
    
    // Update status
    await db.query('UPDATE events SET status = ? WHERE id = ?', [status, id]);
    
    res.json({ message: 'Event status updated successfully' });
  } catch (error) {
    console.error('Update event status error:', error);
    res.status(500).json({ message: 'Server error' });
  }
};
</file>

<file path="backend/api/controllers/notificationController.js">
const db = require('../../config/database');
const logger = require('../../utils/logger');

/**
 * Get all notifications for a specific user
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
exports.getUserNotifications = async (req, res) => {
  try {
    const userId = req.user.id; // Assuming auth middleware adds user to req
    const query = `
      SELECT * FROM notifications 
      WHERE user_id = ? 
      ORDER BY created_at DESC
    `;
    
    const [notifications] = await db.query(query, [userId]);
    
    return res.status(200).json({
      success: true,
      count: notifications.length,
      data: notifications
    });
  } catch (error) {
    logger.error(`Error getting user notifications: ${error.message}`);
    return res.status(500).json({
      success: false,
      message: 'Server Error'
    });
  }
};

/**
 * Get unread notifications count for a user
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
exports.getUnreadCount = async (req, res) => {
  try {
    const userId = req.user.id;
    const query = `
      SELECT COUNT(*) as unreadCount 
      FROM notifications 
      WHERE user_id = ? AND read_status = FALSE
    `;
    
    const [result] = await db.query(query, [userId]);
    
    return res.status(200).json({
      success: true,
      unreadCount: result[0].unreadCount
    });
  } catch (error) {
    logger.error(`Error getting unread notification count: ${error.message}`);
    return res.status(500).json({
      success: false,
      message: 'Server Error'
    });
  }
};

/**
 * Create a new notification
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
exports.createNotification = async (req, res) => {
  try {
    const { user_id, content, type, related_id } = req.body;
    
    if (!user_id || !content || !type) {
      return res.status(400).json({
        success: false,
        message: 'Please provide all required fields'
      });
    }
    
    const query = `
      INSERT INTO notifications (user_id, content, type, related_id)
      VALUES (?, ?, ?, ?)
    `;
    
    const [result] = await db.query(query, [user_id, content, type, related_id || null]);
    
    if (result.affectedRows === 0) {
      return res.status(400).json({
        success: false,
        message: 'Notification could not be created'
      });
    }
    
    const [newNotification] = await db.query(
      'SELECT * FROM notifications WHERE id = ?',
      [result.insertId]
    );
    
    return res.status(201).json({
      success: true,
      data: newNotification[0]
    });
  } catch (error) {
    logger.error(`Error creating notification: ${error.message}`);
    return res.status(500).json({
      success: false,
      message: 'Server Error'
    });
  }
};

/**
 * Mark a notification as read
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
exports.markAsRead = async (req, res) => {
  try {
    const notificationId = req.params.id;
    const userId = req.user.id;
    
    // Verify notification belongs to the user
    const [notification] = await db.query(
      'SELECT * FROM notifications WHERE id = ? AND user_id = ?',
      [notificationId, userId]
    );
    
    if (notification.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'Notification not found or does not belong to user'
      });
    }
    
    const query = `
      UPDATE notifications 
      SET read_status = TRUE 
      WHERE id = ?
    `;
    
    await db.query(query, [notificationId]);
    
    return res.status(200).json({
      success: true,
      message: 'Notification marked as read'
    });
  } catch (error) {
    logger.error(`Error marking notification as read: ${error.message}`);
    return res.status(500).json({
      success: false,
      message: 'Server Error'
    });
  }
};

/**
 * Mark all notifications as read for a user
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
exports.markAllAsRead = async (req, res) => {
  try {
    const userId = req.user.id;
    
    const query = `
      UPDATE notifications 
      SET read_status = TRUE 
      WHERE user_id = ? AND read_status = FALSE
    `;
    
    const [result] = await db.query(query, [userId]);
    
    return res.status(200).json({
      success: true,
      message: `${result.affectedRows} notifications marked as read`
    });
  } catch (error) {
    logger.error(`Error marking all notifications as read: ${error.message}`);
    return res.status(500).json({
      success: false,
      message: 'Server Error'
    });
  }
};

/**
 * Delete a notification
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
exports.deleteNotification = async (req, res) => {
  try {
    const notificationId = req.params.id;
    const userId = req.user.id;
    
    // Verify notification belongs to the user
    const [notification] = await db.query(
      'SELECT * FROM notifications WHERE id = ? AND user_id = ?',
      [notificationId, userId]
    );
    
    if (notification.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'Notification not found or does not belong to user'
      });
    }
    
    await db.query('DELETE FROM notifications WHERE id = ?', [notificationId]);
    
    return res.status(200).json({
      success: true,
      message: 'Notification deleted successfully'
    });
  } catch (error) {
    logger.error(`Error deleting notification: ${error.message}`);
    return res.status(500).json({
      success: false,
      message: 'Server Error'
    });
  }
};

/**
 * Delete all read notifications for a user
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
exports.deleteAllRead = async (req, res) => {
  try {
    const userId = req.user.id;
    
    const [result] = await db.query(
      'DELETE FROM notifications WHERE user_id = ? AND read_status = TRUE',
      [userId]
    );
    
    return res.status(200).json({
      success: true,
      message: `${result.affectedRows} read notifications deleted`
    });
  } catch (error) {
    logger.error(`Error deleting read notifications: ${error.message}`);
    return res.status(500).json({
      success: false,
      message: 'Server Error'
    });
  }
};
</file>

<file path="backend/api/controllers/recommendationController.js">
const db = require('../../config/database');
const logger = require('../../utils/logger');
const aiService = require('../../services/aiService');

/**
 * Get all recommendations for a user
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
exports.getUserRecommendations = async (req, res) => {
  try {
    const userId = req.user.id;
    
    const query = `
      SELECT r.*, e.title, e.description, e.date, e.time, e.location, e.avg_rating, e.status
      FROM recommendations r
      JOIN events e ON r.event_id = e.id
      WHERE r.user_id = ?
      ORDER BY r.score DESC
    `;
    
    const [recommendations] = await db.query(query, [userId]);
    
    return res.status(200).json({
      success: true,
      count: recommendations.length,
      data: recommendations
    });
  } catch (error) {
    logger.error(`Error getting user recommendations: ${error.message}`);
    return res.status(500).json({
      success: false,
      message: 'Server Error'
    });
  }
};

/**
 * Generate new recommendations for a user
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
exports.generateRecommendations = async (req, res) => {
  try {
    const userId = req.user.id;
    
    // Get user's preferences (based on past reviews and calendar)
    const [userReviews] = await db.query(`
      SELECT r.*, e.title, e.description, c.name as category
      FROM reviews r
      JOIN events e ON r.event_id = e.id
      JOIN event_categories ec ON e.id = ec.event_id
      JOIN categories c ON ec.category_id = c.id
      WHERE r.user_id = ?
    `, [userId]);
    
    // Get user's calendar entries
    const [userCalendar] = await db.query(`
      SELECT c.*, e.title, e.description
      FROM calendars c
      JOIN events e ON c.event_id = e.id
      WHERE c.user_id = ?
    `, [userId]);
    
    // Get available upcoming events that user hasn't reviewed or added to calendar
    const [availableEvents] = await db.query(`
      SELECT e.*, GROUP_CONCAT(c.name) as categories
      FROM events e
      JOIN event_categories ec ON e.id = ec.event_id
      JOIN categories c ON ec.category_id = c.id
      WHERE e.date >= CURDATE()
      AND e.status = 'upcoming'
      AND e.id NOT IN (
        SELECT event_id FROM reviews WHERE user_id = ?
      )
      AND e.id NOT IN (
        SELECT event_id FROM calendars WHERE user_id = ?
      )
      GROUP BY e.id
    `, [userId, userId]);
    
    if (availableEvents.length === 0) {
      return res.status(200).json({
        success: true,
        message: 'No new events available for recommendations',
        data: []
      });
    }
    
    // Generate recommendations using AI service
    const recommendations = await aiService.generateRecommendations(
      userId,
      userReviews,
      userCalendar,
      availableEvents
    );
    
    // Save recommendations to database
    const insertPromises = recommendations.map(async (rec) => {
      // Check if recommendation already exists
      const [existing] = await db.query(
        'SELECT * FROM recommendations WHERE user_id = ? AND event_id = ?',
        [userId, rec.event_id]
      );
      
      if (existing.length > 0) {
        // Update existing recommendation
        await db.query(
          'UPDATE recommendations SET score = ?, reason = ? WHERE user_id = ? AND event_id = ?',
          [rec.score, rec.reason, userId, rec.event_id]
        );
      } else {
        // Insert new recommendation
        await db.query(
          'INSERT INTO recommendations (user_id, event_id, score, reason) VALUES (?, ?, ?, ?)',
          [userId, rec.event_id, rec.score, rec.reason]
        );
      }
    });
    
    await Promise.all(insertPromises);
    
    // Get updated recommendations
    const [updatedRecs] = await db.query(`
      SELECT r.*, e.title, e.description, e.date, e.time, e.location, e.avg_rating
      FROM recommendations r
      JOIN events e ON r.event_id = e.id
      WHERE r.user_id = ?
      ORDER BY r.score DESC
    `, [userId]);
    
    return res.status(200).json({
      success: true,
      count: updatedRecs.length,
      data: updatedRecs
    });
  } catch (error) {
    logger.error(`Error generating recommendations: ${error.message}`);
    return res.status(500).json({
      success: false,
      message: 'Server Error'
    });
  }
};

/**
 * Get top recommendations for a user (limited number)
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
exports.getTopRecommendations = async (req, res) => {
  try {
    const userId = req.user.id;
    const { limit = 5 } = req.query; // Default to top 5
    
    const query = `
      SELECT r.*, e.title, e.description, e.date, e.time, e.location, e.avg_rating, e.status
      FROM recommendations r
      JOIN events e ON r.event_id = e.id
      WHERE r.user_id = ? AND e.date >= CURDATE() AND e.status = 'upcoming'
      ORDER BY r.score DESC
      LIMIT ?
    `;
    
    const [recommendations] = await db.query(query, [userId, parseInt(limit)]);
    
    return res.status(200).json({
      success: true,
      count: recommendations.length,
      data: recommendations
    });
  } catch (error) {
    logger.error(`Error getting top recommendations: ${error.message}`);
    return res.status(500).json({
      success: false,
      message: 'Server Error'
    });
  }
};

/**
 * Delete a recommendation
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
exports.deleteRecommendation = async (req, res) => {
  try {
    const recommendationId = req.params.id;
    const userId = req.user.id;
    
    // Verify recommendation belongs to user
    const [recommendation] = await db.query(
      'SELECT * FROM recommendations WHERE id = ? AND user_id = ?',
      [recommendationId, userId]
    );
    
    if (recommendation.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'Recommendation not found or does not belong to user'
      });
    }
    
    await db.query('DELETE FROM recommendations WHERE id = ?', [recommendationId]);
    
    return res.status(200).json({
      success: true,
      message: 'Recommendation deleted successfully'
    });
  } catch (error) {
    logger.error(`Error deleting recommendation: ${error.message}`);
    return res.status(500).json({
      success: false,
      message: 'Server Error'
    });
  }
};

/**
 * Provide feedback on a recommendation (for improving future recommendations)
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
exports.provideFeedback = async (req, res) => {
  try {
    const recommendationId = req.params.id;
    const userId = req.user.id;
    const { feedback } = req.body;
    
    if (!feedback || !['relevant', 'not_relevant'].includes(feedback)) {
      return res.status(400).json({
        success: false,
        message: 'Please provide valid feedback (relevant or not_relevant)'
      });
    }
    
    // Verify recommendation belongs to user
    const [recommendation] = await db.query(
      'SELECT * FROM recommendations WHERE id = ? AND user_id = ?',
      [recommendationId, userId]
    );
    
    if (recommendation.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'Recommendation not found or does not belong to user'
      });
    }
    
    // Store feedback in AI service for model improvement
    await aiService.storeRecommendationFeedback(
      userId,
      recommendation[0].event_id,
      feedback
    );
    
    return res.status(200).json({
      success: true,
      message: 'Feedback provided successfully'
    });
  } catch (error) {
    logger.error(`Error providing recommendation feedback: ${error.message}`);
    return res.status(500).json({
      success: false,
      message: 'Server Error'
    });
  }
};

/**
 * Get recommendations by category
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
exports.getRecommendationsByCategory = async (req, res) => {
  try {
    const userId = req.user.id;
    const { categoryId } = req.params;
    
    // Verify category exists
    const [category] = await db.query(
      'SELECT * FROM categories WHERE id = ?',
      [categoryId]
    );
    
    if (category.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'Category not found'
      });
    }
    
    const query = `
      SELECT r.*, e.title, e.description, e.date, e.time, e.location, e.avg_rating
      FROM recommendations r
      JOIN events e ON r.event_id = e.id
      JOIN event_categories ec ON e.id = ec.event_id
      WHERE r.user_id = ? 
      AND ec.category_id = ?
      AND e.date >= CURDATE()
      ORDER BY r.score DESC
    `;
    
    const [recommendations] = await db.query(query, [userId, categoryId]);
    
    return res.status(200).json({
      success: true,
      count: recommendations.length,
      category: category[0].name,
      data: recommendations
    });
  } catch (error) {
    logger.error(`Error getting recommendations by category: ${error.message}`);
    return res.status(500).json({
      success: false,
      message: 'Server Error'
    });
  }
};
</file>

<file path="backend/api/controllers/reviewController.js">
const db = require('../../config/database');
const aiService = require('../../services/aiService');

exports.createReview = async (req, res) => {
  try {
    const { eventId, rating, content } = req.body;
    const userId = req.user.id;
    
    // Check if event exists
    const [events] = await db.query('SELECT * FROM events WHERE id = ?', [eventId]);
    
    if (events.length === 0) {
      return res.status(404).json({ message: 'Event not found' });
    }
    
    // Check if user has already reviewed this event
    const [existingReviews] = await db.query(
      'SELECT * FROM reviews WHERE user_id = ? AND event_id = ?',
      [userId, eventId]
    );
    
    if (existingReviews.length > 0) {
      return res.status(400).json({ message: 'You have already reviewed this event' });
    }
    
    // Analyze sentiment using AI service
    const sentimentAnalysis = await aiService.analyzeSentiment(content);
    const { score: sentimentScore, category: sentimentCategory } = sentimentAnalysis;
    
    // Insert review
    const [result] = await db.query(
      'INSERT INTO reviews (user_id, event_id, rating, content, sentiment_score, sentiment_category) VALUES (?, ?, ?, ?, ?, ?)',
      [userId, eventId, rating, content, sentimentScore, sentimentCategory]
    );
    
    // Update event's average rating
    await updateEventAverageRating(eventId);
    
    // Create notification for event organizer
    const [eventDetails] = await db.query(
      'SELECT organizer_id, title FROM events WHERE id = ?',
      [eventId]
    );
    
    if (eventDetails.length > 0) {
      const organizerId = eventDetails[0].organizer_id;
      const eventTitle = eventDetails[0].title;
      
      await db.query(
        'INSERT INTO notifications (user_id, content, type, related_id) VALUES (?, ?, ?, ?)',
        [
          organizerId,
          `Your event "${eventTitle}" received a new ${rating}-star review`,
          'review',
          result.insertId
        ]
      );
    }
    
    res.status(201).json({
      id: result.insertId,
      userId,
      eventId,
      rating,
      content,
      sentimentScore,
      sentimentCategory,
      message: 'Review created successfully'
    });
  } catch (error) {
    console.error('Create review error:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

exports.getEventReviews = async (req, res) => {
  try {
    const { eventId } = req.params;
    const { sort = 'newest', page = 1, limit = 10 } = req.query;
    
    // Check if event exists
    const [events] = await db.query('SELECT * FROM events WHERE id = ?', [eventId]);
    
    if (events.length === 0) {
      return res.status(404).json({ message: 'Event not found' });
    }
    
    // Determine sort order
    let orderBy;
    switch (sort) {
      case 'oldest':
        orderBy = 'r.created_at ASC';
        break;
      case 'highest':
        orderBy = 'r.rating DESC, r.created_at DESC';
        break;
      case 'lowest':
        orderBy = 'r.rating ASC, r.created_at DESC';
        break;
      case 'newest':
      default:
        orderBy = 'r.created_at DESC';
    }
    
    // Calculate offset for pagination
    const offset = (page - 1) * limit;
    
    // Get reviews with user information
    const [reviews] = await db.query(`
      SELECT r.*, u.username, u.profile_pic
      FROM reviews r
      JOIN users u ON r.user_id = u.id
      WHERE r.event_id = ?
      ORDER BY ${orderBy}
      LIMIT ? OFFSET ?
    `, [eventId, parseInt(limit), parseInt(offset)]);
    
    // Get total count for pagination
    const [countResult] = await db.query(
      'SELECT COUNT(*) as total FROM reviews WHERE event_id = ?',
      [eventId]
    );
    
    const total = countResult[0].total;
    
    res.json({
      reviews,
      pagination: {
        total,
        page: parseInt(page),
        pageSize: parseInt(limit),
        totalPages: Math.ceil(total / limit)
      }
    });
  } catch (error) {
    console.error('Get event reviews error:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

exports.getUserReviews = async (req, res) => {
  try {
    const userId = req.params.userId || req.user.id;
    const { page = 1, limit = 10 } = req.query;
    
    // Calculate offset for pagination
    const offset = (page - 1) * limit;
    
    // Get reviews with event information
    const [reviews] = await db.query(`
      SELECT r.*, e.title as event_title, e.date as event_date, e.image as event_image
      FROM reviews r
      JOIN events e ON r.event_id = e.id
      WHERE r.user_id = ?
      ORDER BY r.created_at DESC
      LIMIT ? OFFSET ?
    `, [userId, parseInt(limit), parseInt(offset)]);
    
    // Get total count for pagination
    const [countResult] = await db.query(
      'SELECT COUNT(*) as total FROM reviews WHERE user_id = ?',
      [userId]
    );
    
    const total = countResult[0].total;
    
    res.json({
      reviews,
      pagination: {
        total,
        page: parseInt(page),
        pageSize: parseInt(limit),
        totalPages: Math.ceil(total / limit)
      }
    });
  } catch (error) {
    console.error('Get user reviews error:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

exports.getReviewById = async (req, res) => {
  try {
    const { id } = req.params;
    
    // Get review with user and event information
    const [reviews] = await db.query(`
      SELECT r.*, u.username, u.profile_pic, e.title as event_title
      FROM reviews r
      JOIN users u ON r.user_id = u.id
      JOIN events e ON r.event_id = e.id
      WHERE r.id = ?
    `, [id]);
    
    if (reviews.length === 0) {
      return res.status(404).json({ message: 'Review not found' });
    }
    
    res.json(reviews[0]);
  } catch (error) {
    console.error('Get review error:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

exports.updateReview = async (req, res) => {
  try {
    const { id } = req.params;
    const { rating, content } = req.body;
    const userId = req.user.id;
    
    // Check if review exists and belongs to the user
    const [reviews] = await db.query(
      'SELECT * FROM reviews WHERE id = ?',
      [id]
    );
    
    if (reviews.length === 0) {
      return res.status(404).json({ message: 'Review not found' });
    }
    
    if (reviews[0].user_id !== userId && !req.user.isAdmin) {
      return res.status(403).json({ message: 'Not authorized to update this review' });
    }
    
    // Update fields as needed
    let updateFields = [];
    let queryParams = [];
    
    if (rating) {
      updateFields.push('rating = ?');
      queryParams.push(rating);
    }
    
    if (content) {
      // Re-analyze sentiment if content is updated
      const sentimentAnalysis = await aiService.analyzeSentiment(content);
      const { score: sentimentScore, category: sentimentCategory } = sentimentAnalysis;
      
      updateFields.push('content = ?');
      queryParams.push(content);
      
      updateFields.push('sentiment_score = ?');
      queryParams.push(sentimentScore);
      
      updateFields.push('sentiment_category = ?');
      queryParams.push(sentimentCategory);
    }
    
    if (updateFields.length === 0) {
      return res.status(400).json({ message: 'No fields to update' });
    }
    
    // Add review ID to params
    queryParams.push(id);
    
    const query = `UPDATE reviews SET ${updateFields.join(', ')} WHERE id = ?`;
    
    await db.query(query, queryParams);
    
    // Update event's average rating
    const eventId = reviews[0].event_id;
    await updateEventAverageRating(eventId);
    
    res.json({ message: 'Review updated successfully' });
  } catch (error) {
    console.error('Update review error:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

exports.deleteReview = async (req, res) => {
  try {
    const { id } = req.params;
    const userId = req.user.id;
    
    // Check if review exists and belongs to the user
    const [reviews] = await db.query(
      'SELECT * FROM reviews WHERE id = ?',
      [id]
    );
    
    if (reviews.length === 0) {
      return res.status(404).json({ message: 'Review not found' });
    }
    
    if (reviews[0].user_id !== userId && !req.user.isAdmin) {
      return res.status(403).json({ message: 'Not authorized to delete this review' });
    }
    
    // Store event ID before deleting the review
    const eventId = reviews[0].event_id;
    
    // Delete review
    await db.query('DELETE FROM reviews WHERE id = ?', [id]);
    
    // Update event's average rating
    await updateEventAverageRating(eventId);
    
    res.json({ message: 'Review deleted successfully' });
  } catch (error) {
    console.error('Delete review error:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

exports.getReviewStats = async (req, res) => {
  try {
    const { eventId } = req.params;
    
    // Check if event exists
    const [events] = await db.query('SELECT * FROM events WHERE id = ?', [eventId]);
    
    if (events.length === 0) {
      return res.status(404).json({ message: 'Event not found' });
    }
    
    // Get review statistics
    const [reviewStats] = await db.query(`
      SELECT 
        COUNT(*) as total_reviews,
        AVG(rating) as average_rating,
        COUNT(CASE WHEN rating = 5 THEN 1 END) as five_star,
        COUNT(CASE WHEN rating = 4 THEN 1 END) as four_star,
        COUNT(CASE WHEN rating = 3 THEN 1 END) as three_star,
        COUNT(CASE WHEN rating = 2 THEN 1 END) as two_star,
        COUNT(CASE WHEN rating = 1 THEN 1 END) as one_star,
        COUNT(CASE WHEN sentiment_category = 'positive' THEN 1 END) as positive_reviews,
        COUNT(CASE WHEN sentiment_category = 'neutral' THEN 1 END) as neutral_reviews,
        COUNT(CASE WHEN sentiment_category = 'negative' THEN 1 END) as negative_reviews
      FROM reviews
      WHERE event_id = ?
    `, [eventId]);
    
    res.json(reviewStats[0]);
  } catch (error) {
    console.error('Get review stats error:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

// Helper function to update event's average rating
async function updateEventAverageRating(eventId) {
  try {
    // Calculate new average rating
    const [avgResult] = await db.query(
      'SELECT AVG(rating) as avg_rating FROM reviews WHERE event_id = ?',
      [eventId]
    );
    
    const avgRating = avgResult[0].avg_rating || 0;
    
    // Update event's avg_rating
    await db.query(
      'UPDATE events SET avg_rating = ? WHERE id = ?',
      [avgRating, eventId]
    );
    
    return avgRating;
  } catch (error) {
    console.error('Update average rating error:', error);
    throw error;
  }
}
</file>

<file path="backend/api/middleware/auth.js">
const jwt = require('jsonwebtoken');
const db = require('../../config/database');
require('dotenv').config();

exports.authenticate = async (req, res, next) => {
  try {
    // Get token from header
    const authHeader = req.headers.authorization;
    
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({
        success: false,
        message: 'Authentication failed. No token provided.'
      });
    }
    
    const token = authHeader.split(' ')[1];
    
    // Verify token
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    
    // Check if user exists
    const [user] = await db.query('SELECT id, username, email, is_admin FROM users WHERE id = ?', [decoded.id]);
    
    if (user.length === 0) {
      return res.status(401).json({
        success: false,
        message: 'User not found'
      });
    }
    
    // Set user in request
    req.user = user[0];
    next();
  } catch (error) {
    if (error.name === 'JsonWebTokenError') {
      return res.status(401).json({
        success: false,
        message: 'Invalid token.'
      });
    }
    
    if (error.name === 'TokenExpiredError') {
      return res.status(401).json({
        success: false,
        message: 'Token expired.'
      });
    }
    
    return res.status(500).json({
      success: false,
      message: 'Server error.'
    });
  }
};

exports.isAdmin = (req, res, next) => {
  if (!req.user.is_admin) {
    return res.status(403).json({
      success: false,
      message: 'Access denied. Admin privileges required.'
    });
  }
  next();
};
</file>

<file path="backend/api/models/calendarModel.js">
// calendarModel.js
const db = require('../../config/database');

/**
 * Calendar model
 */
const Calendar = {
  /**
   * Add event to user's calendar
   * @param {Object} calendarData - Calendar data
   * @returns {Object} - Created calendar entry
   */
  async addEvent(calendarData) {
    try {
      // Define reminder settings JSON if provi`ded
      let reminderSettings = null;
      if (calendarData.reminder_settings) {
        if (typeof calendarData.reminder_settings === 'string') {
          reminderSettings = calendarData.reminder_settings;
        } else {
          reminderSettings = JSON.stringify(calendarData.reminder_settings);
        }
      }

      // Insert calendar entry into database
      const result = await db.query(
        `INSERT INTO calendars (user_id, event_id, reminder_settings, is_synced) VALUES (?, ?, ?, ?)`,
        [
          calendarData.user_id,
          calendarData.event_id,
          reminderSettings,
          calendarData.is_synced || false
        ]
      );

      // Get the created calendar entry
      const [calendar] = await this.findById(result.insertId);
      return calendar;
    } catch (error) {
      throw error;
    }
  },

  /**
   * Find calendar entry by ID
   * @param {number} id - Calendar ID
   * @returns {Object} - Calendar object
   */
  async findById(id) {
    return await db.query(
      `SELECT c.*, e.title as event_title, e.date as event_date, e.time as event_time
       FROM calendars c
       JOIN events e ON c.event_id = e.id
       WHERE c.id = ?`,
      [id]
    );
  },

  /**
   * Find calendar entry by user and event
   * @param {number} userId - User ID
   * @param {number} eventId - Event ID
   * @returns {Object} - Calendar object
   */
  async findByUserAndEvent(userId, eventId) {
    return await db.query(
      `SELECT c.*, e.title as event_title, e.date as event_date, e.time as event_time
       FROM calendars c
       JOIN events e ON c.event_id = e.id
       WHERE c.user_id = ? AND c.event_id = ?`,
      [userId, eventId]
    );
  },

  /**
   * Update calendar entry
   * @param {number} id - Calendar ID
   * @param {Object} calendarData - Calendar data to update
   * @returns {Object} - Updated calendar object
   */
  async update(id, calendarData) {
    // Create dynamic update query based on provided fields
    const fields = [];
    const values = [];

    if (calendarData.reminder_settings) {
      let reminderSettings = null;
      if (typeof calendarData.reminder_settings === 'string') {
        reminderSettings = calendarData.reminder_settings;
      } else {
        reminderSettings = JSON.stringify(calendarData.reminder_settings);
      }
      
      fields.push('reminder_settings = ?');
      values.push(reminderSettings);
    }
    
    if (calendarData.is_synced !== undefined) {
      fields.push('is_synced = ?');
      values.push(calendarData.is_synced);
    }

    // Only proceed if there are fields to update
    if (fields.length === 0) {
      return await this.findById(id);
    }

    // Add ID to values array
    values.push(id);

    // Execute update query
    await db.query(
      `UPDATE calendars SET ${fields.join(', ')} WHERE id = ?`,
      values
    );

    // Return updated calendar entry
    const [updatedCalendar] = await this.findById(id);
    return updatedCalendar;
  },

  /**
   * Remove event from user's calendar
   * @param {number} id - Calendar ID
   * @returns {boolean} - Success status
   */
  async removeEvent(id) {
    const result = await db.query('DELETE FROM calendars WHERE id = ?', [id]);
    return result.affectedRows > 0;
  },

  /**
   * Get user's calendar events
   * @param {number} userId - User ID
   * @param {Object} options - Query options (limit, offset, filter)
   * @returns {Array} - Array of calendar objects
   */
  async getUserEvents(userId, options = { limit: 10, offset: 0, filter: {} }) {
    let query = `SELECT c.*, e.title, e.description, e.date, e.time, e.location, e.status, e.image
                 FROM calendars c
                 JOIN events e ON c.event_id = e.id
                 WHERE c.user_id = ?`;
    
    const queryParams = [userId];
    
    // Add filter conditions
    if (options.filter) {
      if (options.filter.dateFrom) {
        query += ' AND e.date >= ?';
        queryParams.push(options.filter.dateFrom);
      }
      
      if (options.filter.dateTo) {
        query += ' AND e.date <= ?';
        queryParams.push(options.filter.dateTo);
      }
      
      if (options.filter.status) {
        query += ' AND e.status = ?';
        queryParams.push(options.filter.status);
      }
    }
    
    // Add sorting and pagination
    query += ' ORDER BY e.date ASC, e.time ASC LIMIT ? OFFSET ?';
    queryParams.push(options.limit, options.offset);
    
    return await db.query(query, queryParams);
  },

  /**
   * Get upcoming events for reminder
   * @param {number} minutesAhead - Minutes ahead to look for events
   * @returns {Array} - Array of calendar objects with events coming up
   */
  async getUpcomingEvents(minutesAhead = 60) {
    const now = new Date();
    const targetDate = new Date(now.getTime() + minutesAhead * 60000);
    
    return await db.query(
      `SELECT c.*, e.title, e.date, e.time, e.location, u.email as user_email, u.username as user_name
       FROM calendars c
       JOIN events e ON c.event_id = e.id
       JOIN users u ON c.user_id = u.id
       WHERE e.date = CURDATE() 
       AND TIME_TO_SEC(TIMEDIFF(e.time, CURTIME())) BETWEEN 0 AND ?
       AND JSON_EXTRACT(c.reminder_settings, '$.enabled') = TRUE`,
      [minutesAhead * 60]
    );
  },

  /**
   * Check if user has added event to calendar
   * @param {number} userId - User ID
   * @param {number} eventId - Event ID
   * @returns {boolean} - True if event is in user's calendar
   */
  async hasEvent(userId, eventId) {
    const [result] = await db.query(
      `SELECT COUNT(*) as count
       FROM calendars
       WHERE user_id = ? AND event_id = ?`,
      [userId, eventId]
    );
    
    return result.count > 0;
  }
};

module.exports = Calendar;
</file>

<file path="backend/api/routes/calendar.js">
const express = require('express');
const router = express.Router();
const calendarController = require('../controllers/calendarController');
const { authenticate } = require('../middleware/auth');

// Apply authentication middleware to all routes
router.use(authenticate);

// Get all calendar entries for a user
router.get('/', calendarController.getUserCalendarEntries);

// Get upcoming events from calendar
router.get('/upcoming', calendarController.getUpcomingEvents);

// Add an event to user's calendar
router.post('/', calendarController.addToCalendar);

// Update reminder settings
router.put('/:id/reminder', calendarController.updateReminderSettings);

// Update sync status
router.put('/:id/sync', calendarController.updateSyncStatus);

// Remove event from calendar
router.delete('/:id', calendarController.removeFromCalendar);

module.exports = router;
</file>

<file path="backend/api/routes/categories.js">
const express = require('express');
const router = express.Router();
const categoryController = require('../controllers/categoryController');
const auth = require('../middleware/auth');
const validation = require('../middleware/validation');

// Public routes
router.get('/', categoryController.getAllCategories);
router.get('/:id', categoryController.getCategoryById);

// Admin routes
router.post('/', auth.authenticateUser, auth.authorizeAdmin, validation.validateCategoryCreation, categoryController.createCategory);
router.put('/:id', auth.authenticateUser, auth.authorizeAdmin, validation.validateCategoryUpdate, categoryController.updateCategory);
router.delete('/:id', auth.authenticateUser, auth.authorizeAdmin, categoryController.deleteCategory);

module.exports = router;
</file>

<file path="backend/api/routes/events.js">
const express = require('express');
const router = express.Router();
const eventController = require('../controllers/eventController');
const auth = require('../middleware/auth');
const validation = require('../middleware/validation');

// Public routes
router.get('/', eventController.getAllEvents);
router.get('/featured', eventController.getFeaturedEvents);
router.get('/search', eventController.searchEvents);
router.get('/:id', eventController.getEventById);
router.get('/category/:categoryId', eventController.getEventsByCategory);

// Protected routes
router.post('/', auth.authenticateUser, validation.validateEventCreation, eventController.createEvent);
router.put('/:id', auth.authenticateUser, validation.validateEventUpdate, eventController.updateEvent);
router.delete('/:id', auth.authenticateUser, eventController.deleteEvent);
router.get('/user/organized', auth.authenticateUser, eventController.getOrganizedEvents);
router.get('/user/attending', auth.authenticateUser, eventController.getAttendingEvents);
router.put('/:id/status', auth.authenticateUser, validation.validateEventStatusUpdate, eventController.updateEventStatus);
router.post('/:id/image', auth.authenticateUser, eventController.uploadEventImage);

// Admin routes
router.get('/admin/all', auth.authenticateUser, auth.authorizeAdmin, eventController.adminGetAllEvents);
router.put('/admin/events/:id', auth.authenticateUser, auth.authorizeAdmin, eventController.adminUpdateEvent);
router.delete('/admin/events/:id', auth.authenticateUser, auth.authorizeAdmin, eventController.adminDeleteEvent);

module.exports = router;
</file>

<file path="backend/api/routes/notifications.js">
const express = require('express');
const router = express.Router();
const notificationController = require('../controllers/notificationController');
const { authenticate } = require('../middleware/auth');

// Apply authentication middleware to all routes
router.use(authenticate);

// Get all notifications for a user
router.get('/', notificationController.getUserNotifications);

// Get unread notifications count
router.get('/unread', notificationController.getUnreadCount);

// Create a new notification
router.post('/', notificationController.createNotification);

// Mark a notification as read
router.put('/:id/read', notificationController.markAsRead);

// Mark all notifications as read
router.put('/read-all', notificationController.markAllAsRead);

// Delete a notification
router.delete('/:id', notificationController.deleteNotification);

// Delete all read notifications
router.delete('/read', notificationController.deleteAllRead);

module.exports = router;
</file>

<file path="backend/api/routes/recommendations.js">
const express = require('express');
const router = express.Router();
const recommendationController = require('../controllers/recommendationController');
const { authenticate } = require('../middleware/auth');

// Apply authentication middleware to all routes
router.use(authenticate);

// Get all recommendations for a user
router.get('/', recommendationController.getUserRecommendations);

// Get top recommendations
router.get('/top', recommendationController.getTopRecommendations);

// Get recommendations by category
router.get('/category/:categoryId', recommendationController.getRecommendationsByCategory);

// Generate new recommendations
router.post('/generate', recommendationController.generateRecommendations);

// Provide feedback on a recommendation
router.post('/:id/feedback', recommendationController.provideFeedback);

// Delete a recommendation
router.delete('/:id', recommendationController.deleteRecommendation);

module.exports = router;
</file>

<file path="backend/api/routes/reviews.js">
const express = require('express');
const router = express.Router();
const reviewController = require('../controllers/reviewController');
const auth = require('../middleware/auth');
const validation = require('../middleware/validation');

// Public routes
router.get('/event/:eventId', reviewController.getReviewsByEvent);
router.get('/event/:eventId/summary', reviewController.getEventReviewSummary);

// Protected routes
router.post('/', auth.authenticateUser, validation.validateReviewCreation, reviewController.createReview);
router.put('/:id', auth.authenticateUser, validation.validateReviewUpdate, reviewController.updateReview);
router.delete('/:id', auth.authenticateUser, reviewController.deleteReview);
router.get('/user', auth.authenticateUser, reviewController.getUserReviews);

// Admin routes
router.get('/admin/all', auth.authenticateUser, auth.authorizeAdmin, reviewController.adminGetAllReviews);
router.delete('/admin/reviews/:id', auth.authenticateUser, auth.authorizeAdmin, reviewController.adminDeleteReview);

module.exports = router;
</file>

<file path="backend/api/routes/users.js">
const express = require('express');
const router = express.Router();
const userController = require('../controllers/userController');
const auth = require('../middleware/auth');
const validation = require('../middleware/validation');

// Public routes
router.post('/register', validation.userRules.createUser, userController.register);
router.post('/login', validation.userRules.login, userController.login);

router.post('/forgot-password', 
  validation.validateEmail || ((req, res, next) => next()), 
  userController.forgotPassword || ((req, res) => res.status(501).json({ error: 'Not implemented' }))
);

router.post('/reset-password', 
  validation.validatePasswordReset || ((req, res, next) => next()), 
  userController.resetPassword || ((req, res) => res.status(501).json({ error: 'Not implemented' }))
);

// Protected routes
router.get('/profile', auth.authenticateUser, 
  userController.getProfile || ((req, res) => res.status(501).json({ error: 'User profile not implemented' }))
);

router.put('/profile', 
  auth.authenticateUser, 
  validation.userRules.updateUser, 
  userController.updateUserProfile || ((req, res) => res.status(501).json({ error: 'Update profile not implemented' }))
);

router.get('/profile/:id', 
  userController.getPublicUserProfile || ((req, res) => res.status(501).json({ error: 'Public profile not implemented' }))
);

router.delete('/account', 
  auth.authenticateUser, 
  userController.deleteAccount || ((req, res) => res.status(501).json({ error: 'Account deletion not implemented' }))
);

// Admin routes
router.get('/admin/users', 
  auth.authenticateUser, 
  auth.authorizeAdmin, 
  // Add fallback function in case getAllUsers is undefined
  (req, res) => {
    if (userController.getAllUsers) {
      return userController.getAllUsers(req, res);
    }
    res.status(501).json({ error: 'Get all users functionality not implemented' });
  }
);

router.put('/admin/users/:id', 
  auth.authenticateUser, 
  auth.authorizeAdmin, 
  validation.validateUserUpdate || validation.userRules.updateUser || ((req, res, next) => next()),
  userController.adminUpdateUser || ((req, res) => res.status(501).json({ error: 'Admin update user not implemented' }))
);

router.delete('/admin/users/:id', 
  auth.authenticateUser, 
  auth.authorizeAdmin, 
  userController.adminDeleteUser || ((req, res) => res.status(501).json({ error: 'Admin delete user not implemented' }))
);

module.exports = router;
</file>

<file path="backend/config/database.js">
const mysql = require('mysql2'); // Import MySQL library

// Create a connection pool
const pool = mysql.createPool({

  host: process.env.DB_HOST || 'localhost',
  user: process.env.DB_USER || 'root',
  password: process.env.DB_PASSWORD || '',
  database: process.env.DB_NAME || 'eventreviews',
  waitForConnections: true,
  connectionLimit: 10,
  queueLimit: 0
});

// Test database connection
async function testConnection() {
  try {
    const connection = await pool.getConnection();
    console.log('Database connection successful');
    connection.release();
    return true;
  } catch (error) {
    console.error('Database connection failed:', error.message);
    return false;
  }
}

// Export the pool and test function
module.exports = pool;
module.exports.testConnection = testConnection;
</file>

<file path="backend/server.js">
const express = require('express');
const cors = require('cors');
const morgan = require('morgan');
const db = require('./config/database');
const logger = require('./utils/logger');

// Import routes
const usersRoutes = require('./api/routes/users');
const eventsRoutes = require('./api/routes/events');
const reviewsRoutes = require('./api/routes/reviews');
const categoriesRoutes = require('./api/routes/categories');
const calendarRoutes = require('./api/routes/calendar');
const notificationsRoutes = require('./api/routes/notifications');
const recommendationsRoutes = require('./api/routes/recommendations');

// Create Express app
const app = express();

// Middleware
app.use(cors());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(morgan('dev'));

// Test database connection
(async () => {
  const connected = await db.testConnection();
  if (!connected) {
    logger.error('Failed to connect to database. Exiting...');
    process.exit(1);
  }
})();

// Routes
app.use('/api/users', usersRoutes);
app.use('/api/events', eventsRoutes);
app.use('/api/reviews', reviewsRoutes);
app.use('/api/categories', categoriesRoutes);
app.use('/api/calendar', calendarRoutes);
app.use('/api/notifications', notificationsRoutes);
app.use('/api/recommendations', recommendationsRoutes);

// Root route
app.get('/', (req, res) => {
  res.send('Event Reviews API is running');
});

// Error handling middleware
app.use((err, req, res, next) => {
  logger.error(`Error: ${err.message}`);
  res.status(err.status || 500).json({
    success: false,
    message: err.message || 'Server Error'
  });
});

// Start server
const PORT = process.env.PORT || 5000;
app.listen(PORT, () => {
  logger.info(`Server running on port ${PORT}`);
});
</file>

<file path="backend/service/ai.service.js">
const logger = require('../utils/logger');

/**
 * Service to handle AI-related functionalities
 */
class AIService {
  /**
   * Generate personalized recommendations for a user
   * @param {Number} userId - User ID
   * @param {Array} userReviews - User's past reviews
   * @param {Array} userCalendar - User's calendar entries
   * @param {Array} availableEvents - Available upcoming events
   * @returns {Array} - Recommended events with scores
   */
  async generateRecommendations(userId, userReviews, userCalendar, availableEvents) {
    try {
      // For now, this is a simplified recommendation algorithm
      // In a real application, this would integrate with an AI service or ML model
      
      // Track user preferences by category
      const categoryPreferences = {};
      
      // Analyze user reviews to determine preferences
      userReviews.forEach(review => {
        const category = review.category;
        if (!categoryPreferences[category]) {
          categoryPreferences[category] = { count: 0, totalRating: 0 };
        }
        
        categoryPreferences[category].count++;
        categoryPreferences[category].totalRating += review.rating;
      });
      
      // Calculate average rating per category
      Object.keys(categoryPreferences).forEach(category => {
        categoryPreferences[category].avgRating = 
          categoryPreferences[category].totalRating / categoryPreferences[category].count;
      });
      
      // Score available events based on preferences
      const recommendations = availableEvents.map(event => {
        const eventCategories = event.categories.split(',');
        let score = 0;
        let matchCount = 0;
        
        // Calculate recommendation score based on category preferences
        eventCategories.forEach(category => {
          if (categoryPreferences[category]) {
            // Higher weight for categories with higher ratings
            score += (categoryPreferences[category].avgRating / 5) * 0.8;
            score += (categoryPreferences[category].count / userReviews.length) * 0.2;
            matchCount++;
          }
        });
        
        // Adjust score based on category matches
        if (matchCount > 0) {
          score = score / matchCount;
        } else {
          // Default score for events with no matching categories
          score = 0.5;
        }
        
        // Add small random factor to prevent identical scores
        score += Math.random() * 0.1;
        
        // Ensure score is between 0 and 1
        score = Math.min(Math.max(score, 0), 1);
        
        let reason = '';
        if (score > 0.8) {
          reason = 'Highly matches your preferences';
        } else if (score > 0.6) {
          reason = 'Similar to events you enjoyed';
        } else if (score > 0.4) {
          reason = 'You might be interested in this';
        } else {
          reason = 'Recommended to diversify your experiences';
        }
        
        return {
          user_id: userId,
          event_id: event.id,
          score: score,
          reason: reason
        };
      });
      
      // Sort by score in descending order
      return recommendations.sort((a, b) => b.score - a.score);
    } catch (error) {
      logger.error(`Error generating recommendations: ${error.message}`);
      return [];
    }
  }
  
  /**
   * Analyze sentiment of a review
   * @param {String} content - Review content
   * @returns {Object} - Sentiment analysis results
   */
  async analyzeSentiment(content) {
    try {
      // Simple sentiment analysis based on keywords
      // In a real application, this would use a proper NLP service
      const positiveWords = ['great', 'excellent', 'amazing', 'good', 'wonderful', 'fantastic', 'enjoyed', 'love'];
      const negativeWords = ['bad', 'terrible', 'awful', 'poor', 'disappointing', 'waste', 'hate', 'dislike'];
      
      const words = content.toLowerCase().split(/\W+/);
      let positiveScore = 0;
      let negativeScore = 0;
      
      words.forEach(word => {
        if (positiveWords.includes(word)) positiveScore++;
        if (negativeWords.includes(word)) negativeScore++;
      });
      
      const totalWords = words.length;
      const sentimentScore = (positiveScore - negativeScore) / (totalWords || 1);
      
      let sentimentCategory = 'neutral';
      if (sentimentScore > 0.05) sentimentCategory = 'positive';
      if (sentimentScore < -0.05) sentimentCategory = 'negative';
      
      return {
        sentimentScore: parseFloat(sentimentScore.toFixed(2)),
        sentimentCategory
      };
    } catch (error) {
      logger.error(`Error analyzing sentiment: ${error.message}`);
      return { sentimentScore: 0, sentimentCategory: 'neutral' };
    }
  }
  
  /**
   * Store recommendation feedback for model improvement
   * @param {Number} userId - User ID
   * @param {Number} eventId - Event ID
   * @param {String} feedback - Feedback (relevant/not_relevant)
   */
  async storeRecommendationFeedback(userId, eventId, feedback) {
    try {
      // In a real application, this would store feedback for model retraining
      logger.info(`Recommendation feedback stored: User ${userId}, Event ${eventId}, Feedback: ${feedback}`);
      return true;
    } catch (error) {
      logger.error(`Error storing recommendation feedback: ${error.message}`);
      return false;
    }
  }
}

module.exports = new AIService();const logger = require('../utils/logger');

/**
 * Service to handle AI-related functionalities
 */
class AIService {
  /**
   * Generate personalized recommendations for a user
   * @param {Number} userId - User ID
   * @param {Array} userReviews - User's past reviews
   * @param {Array} userCalendar - User's calendar entries
   * @param {Array} availableEvents - Available upcoming events
   * @returns {Array} - Recommended events with scores
   */
  async generateRecommendations(userId, userReviews, userCalendar, availableEvents) {
    try {
      // For now, this is a simplified recommendation algorithm
      // In a real application, this would integrate with an AI service or ML model
      
      // Track user preferences by category
      const categoryPreferences = {};
      
      // Analyze user reviews to determine preferences
      userReviews.forEach(review => {
        const category = review.category;
        if (!categoryPreferences[category]) {
          categoryPreferences[category] = { count: 0, totalRating: 0 };
        }
        
        categoryPreferences[category].count++;
        categoryPreferences[category].totalRating += review.rating;
      });
      
      // Calculate average rating per category
      Object.keys(categoryPreferences).forEach(category => {
        categoryPreferences[category].avgRating = 
          categoryPreferences[category].totalRating / categoryPreferences[category].count;
      });
      
      // Score available events based on preferences
      const recommendations = availableEvents.map(event => {
        const eventCategories = event.categories.split(',');
        let score = 0;
        let matchCount = 0;
        
        // Calculate recommendation score based on category preferences
        eventCategories.forEach(category => {
          if (categoryPreferences[category]) {
            // Higher weight for categories with higher ratings
            score += (categoryPreferences[category].avgRating / 5) * 0.8;
            score += (categoryPreferences[category].count / userReviews.length) * 0.2;
            matchCount++;
          }
        });
        
        // Adjust score based on category matches
        if (matchCount > 0) {
          score = score / matchCount;
        } else {
          // Default score for events with no matching categories
          score = 0.5;
        }
        
        // Add small random factor to prevent identical scores
        score += Math.random() * 0.1;
        
        // Ensure score is between 0 and 1
        score = Math.min(Math.max(score, 0), 1);
        
        let reason = '';
        if (score > 0.8) {
          reason = 'Highly matches your preferences';
        } else if (score > 0.6) {
          reason = 'Similar to events you enjoyed';
        } else if (score > 0.4) {
          reason = 'You might be interested in this';
        } else {
          reason = 'Recommended to diversify your experiences';
        }
        
        return {
          user_id: userId,
          event_id: event.id,
          score: score,
          reason: reason
        };
      });
      
      // Sort by score in descending order
      return recommendations.sort((a, b) => b.score - a.score);
    } catch (error) {
      logger.error(`Error generating recommendations: ${error.message}`);
      return [];
    }
  }
  
  /**
   * Analyze sentiment of a review
   * @param {String} content - Review content
   * @returns {Object} - Sentiment analysis results
   */
  async analyzeSentiment(content) {
    try {
      // Simple sentiment analysis based on keywords
      // In a real application, this would use a proper NLP service
      const positiveWords = ['great', 'excellent', 'amazing', 'good', 'wonderful', 'fantastic', 'enjoyed', 'love'];
      const negativeWords = ['bad', 'terrible', 'awful', 'poor', 'disappointing', 'waste', 'hate', 'dislike'];
      
      const words = content.toLowerCase().split(/\W+/);
      let positiveScore = 0;
      let negativeScore = 0;
      
      words.forEach(word => {
        if (positiveWords.includes(word)) positiveScore++;
        if (negativeWords.includes(word)) negativeScore++;
      });
      
      const totalWords = words.length;
      const sentimentScore = (positiveScore - negativeScore) / (totalWords || 1);
      
      let sentimentCategory = 'neutral';
      if (sentimentScore > 0.05) sentimentCategory = 'positive';
      if (sentimentScore < -0.05) sentimentCategory = 'negative';
      
      return {
        sentimentScore: parseFloat(sentimentScore.toFixed(2)),
        sentimentCategory
      };
    } catch (error) {
      logger.error(`Error analyzing sentiment: ${error.message}`);
      return { sentimentScore: 0, sentimentCategory: 'neutral' };
    }
  }
  
  /**
   * Store recommendation feedback for model improvement
   * @param {Number} userId - User ID
   * @param {Number} eventId - Event ID
   * @param {String} feedback - Feedback (relevant/not_relevant)
   */
  async storeRecommendationFeedback(userId, eventId, feedback) {
    try {
      // In a real application, this would store feedback for model retraining
      logger.info(`Recommendation feedback stored: User ${userId}, Event ${eventId}, Feedback: ${feedback}`);
      return true;
    } catch (error) {
      logger.error(`Error storing recommendation feedback: ${error.message}`);
      return false;
    }
  }
}

module.exports = new AIService();
</file>

<file path="backend/service/emailService.js">
const nodemailer = require('nodemailer');
const config = require('../config/config');
const logger = require('../utils/logger');
const fs = require('fs').promises;
const path = require('path');
const handlebars = require('handlebars');

/**
 * Email Service for sending notifications and system emails
 */
class EmailService {
  constructor() {
    this.transporter = nodemailer.createTransport({
      host: config.email.host,
      port: config.email.port,
      secure: config.email.secure,
      auth: {
        user: config.email.user,
        pass: config.email.password
      }
    });
    
    this.templates = {};
    this.initializeTemplates();
  }

  /**
   * Initialize email templates
   */
  async initializeTemplates() {
    try {
      // Define template paths
      const templateDir = path.join(__dirname, '../templates/email');
      const templates = [
        'welcome',
        'reset-password',
        'event-reminder',
        'new-review',
        'event-updates',
        'account-verification'
      ];
      
      // Load templates
      for (const template of templates) {
        const content = await fs.readFile(
          path.join(templateDir, `${template}.html`),
          'utf8'
        );
        this.templates[template] = handlebars.compile(content);
      }
      
      logger.info('Email templates loaded successfully');
    } catch (error) {
      logger.error('Failed to load email templates:', error);
    }
  }

  /**
   * Send an email
   * @param {Object} options - Email options
   * @returns {Promise<boolean>} - Success status
   */
  async sendEmail(options) {
    try {
      const { to, subject, template, data } = options;
      
      // Render template if provided
      let html = '';
      if (template && this.templates[template]) {
        html = this.templates[template](data);
      } else if (options.html) {
        html = options.html;
      } else {
        html = options.text || '';
      }
      
      const mailOptions = {
        from: config.email.from,
        to,
        subject,
        text: options.text || '',
        html
      };
      
      // Add attachments if any
      if (options.attachments) {
        mailOptions.attachments = options.attachments;
      }
      
      const info = await this.transporter.sendMail(mailOptions);
      logger.info(`Email sent: ${info.messageId}`);
      return true;
    } catch (error) {
      logger.error('Error sending email:', error);
      return false;
    }
  }

  /**
   * Send welcome email to new user
   * @param {Object} user - User object with email and username
   * @returns {Promise<boolean>} - Success status
   */
  async sendWelcomeEmail(user) {
    return this.sendEmail({
      to: user.email,
      subject: 'Welcome to EventReviews!',
      template: 'welcome',
      data: {
        username: user.username,
        loginUrl: `${config.frontendUrl}/login`
      }
    });
  }

  /**
   * Send password reset email
   * @param {Object} user - User object with email
   * @param {string} resetToken - Password reset token
   * @returns {Promise<boolean>} - Success status
   */
  async sendPasswordResetEmail(user, resetToken) {
    const resetUrl = `${config.frontendUrl}/reset-password?token=${resetToken}`;
    
    return this.sendEmail({
      to: user.email,
      subject: 'Password Reset Request',
      template: 'reset-password',
      data: {
        username: user.username,
        resetUrl,
        expiryTime: '1 hour'
      }
    });
  }

  /**
   * Send event reminder email
   * @param {Object} user - User object
   * @param {Object} event - Event object
   * @param {Object} reminder - Reminder settings
   * @returns {Promise<boolean>} - Success status
   */
  async sendEventReminderEmail(user, event, reminder) {
    return this.sendEmail({
      to: user.email,
      subject: `Reminder: ${event.title} is coming up!`,
      template: 'event-reminder',
      data: {
        username: user.username,
        eventTitle: event.title,
        eventDate: event.date,
        eventTime: event.time,
        eventLocation: event.location,
        eventUrl: `${config.frontendUrl}/events/${event.id}`,
        reminderTime: reminder.time
      }
    });
  }

  /**
   * Send notification about new review
   * @param {Object} user - User (organizer) object
   * @param {Object} event - Event object
   * @param {Object} review - Review object
   * @returns {Promise<boolean>} - Success status
   */
  async sendNewReviewNotification(user, event, review) {
    return this.sendEmail({
      to: user.email,
      subject: `New Review for ${event.title}`,
      template: 'new-review',
      data: {
        username: user.username,
        eventTitle: event.title,
        reviewRating: review.rating,
        reviewContent: review.content,
        eventUrl: `${config.frontendUrl}/events/${event.id}`,
        reviewerName: review.reviewerName
      }
    });
  }

  /**
   * Send batch emails (for newsletters or announcements)
   * @param {Array} recipients - Array of recipient user objects
   * @param {Object} emailData - Email data
   * @returns {Promise<Object>} - Results of sending batch emails
   */
  async sendBatchEmails(recipients, emailData) {
    const results = {
      successful: 0,
      failed: 0,
      failures: []
    };
    
    for (const recipient of recipients) {
      try {
        const sent = await this.sendEmail({
          to: recipient.email,
          subject: emailData.subject,
          template: emailData.template,
          data: {
            ...emailData.data,
            username: recipient.username
          }
        });
        
        if (sent) {
          results.successful++;
        } else {
          results.failed++;
          results.failures.push(recipient.email);
        }
      } catch (error) {
        logger.error(`Failed to send email to ${recipient.email}:`, error);
        results.failed++;
        results.failures.push(recipient.email);
      }
    }
    
    return results;
  }
}

module.exports = new EmailService();
</file>

<file path="backend/service/uploadService.js">
const AWS = require('aws-sdk');
const multer = require('multer');
const path = require('path');
const fs = require('fs');
const { v4: uuidv4 } = require('uuid');
const config = require('../config/config');
const logger = require('../utils/logger');

/**
 * Service for handling file uploads (profile pictures, event images)
 */
class UploadService {
  constructor() {
    this.storage = this.configureStorage();
    this.upload = multer({
      storage: this.storage,
      limits: {
        fileSize: 5 * 1024 * 1024, // 5MB limit
      },
      fileFilter: this.fileFilter
    });
    
    // Configure AWS S3 if enabled
    if (config.storage.type === 's3') {
      this.s3 = new AWS.S3({
        accessKeyId: config.storage.s3.accessKeyId,
        secretAccessKey: config.storage.s3.secretAccessKey,
        region: config.storage.s3.region
      });
    }
  }

  /**
   * Configure storage based on config
   * @returns {multer.StorageEngine} - Configured storage engine
   */
  configureStorage() {
    if (config.storage.type === 'local') {
      // Local storage
      return multer.diskStorage({
        destination: (req, file, cb) => {
          const uploadDir = config.storage.local.uploadDir;
          // Create directory if it doesn't exist
          if (!fs.existsSync(uploadDir)) {
            fs.mkdirSync(uploadDir, { recursive: true });
          }
          cb(null, uploadDir);
        },
        filename: (req, file, cb) => {
          const uniqueName = `${uuidv4()}${path.extname(file.originalname)}`;
          cb(null, uniqueName);
        }
      });
    } else {
      // For S3, use memory storage
      return multer.memoryStorage();
    }
  }

  /**
   * Filter files by type
   * @param {Object} req - Express request object
   * @param {Object} file - Uploaded file object
   * @param {Function} cb - Callback function
   */
  fileFilter(req, file, cb) {
    // Allow only images
    const allowedTypes = /jpeg|jpg|png|gif/;
    const extname = allowedTypes.test(path.extname(file.originalname).toLowerCase());
    const mimetype = allowedTypes.test(file.mimetype);
    
    if (extname && mimetype) {
      return cb(null, true);
    } else {
      cb(new Error('Only image files are allowed!'));
    }
  }

  /**
   * Get multer middleware for specific field
   * @param {string} fieldName - Form field name
   * @returns {Function} - Multer middleware
   */
  getUploadMiddleware(fieldName) {
    return this.upload.single(fieldName);
  }

  /**
   * Upload file to S3
   * @param {Object} file - File object from multer
   * @param {string} folder - Folder name in S3
   * @returns {Promise<string>} - File URL
   */
  async uploadToS3(file, folder = '') {
    try {
      const uniqueName = `${folder}/${uuidv4()}${path.extname(file.originalname)}`;
      
      const params = {
        Bucket: config.storage.s3.bucket,
        Key: uniqueName,
        Body: file.buffer,
        ContentType: file.mimetype,
        ACL: 'public-read'
      };
      
      const result = await this.s3.upload(params).promise();
      logger.info(`File uploaded to S3: ${result.Location}`);
      return result.Location;
    } catch (error) {
      logger.error('Error uploading to S3:', error);
      throw error;
    }
  }

  /**
   * Save file to local storage or S3
   * @param {Object} file - File object from multer
   * @param {string} folder - Folder name
   * @returns {Promise<string>} - File URL or path
   */
  async saveFile(file, folder = '') {
    if (!file) {
      throw new Error('No file provided');
    }
    
    if (config.storage.type === 's3') {
      return await this.uploadToS3(file, folder);
    } else {
      // For local storage, file already saved by multer
      return `${config.baseUrl}/uploads/${file.filename}`;
    }
  }

  /**
   * Delete file from storage
   * @param {string} fileUrl - URL or path of the file
   * @returns {Promise<boolean>} - Success status
   */
  async deleteFile(fileUrl) {
    try {
      if (config.storage.type === 's3') {
        // Extract key from URL
        const key = fileUrl.split('/').slice(3).join('/');
        
        const params = {
          Bucket: config.storage.s3.bucket,
          Key: key
        };
        
        await this.s3.deleteObject(params).promise();
        logger.info(`File deleted from S3: ${key}`);
        return true;
      } else {
        // For local storage
        const filePath = path.join(
          config.storage.local.uploadDir,
          path.basename(fileUrl)
        );
        
        if (fs.existsSync(filePath)) {
          fs.unlinkSync(filePath);
          logger.info(`File deleted from local storage: ${filePath}`);
          return true;
        }
        return false;
      }
    } catch (error) {
      logger.error('Error deleting file:', error);
      return false;
    }
  }

  /**
   * Process event image upload
   * @param {Object} file - Uploaded file object
   * @returns {Promise<string>} - File URL
   */
  async processEventImage(file) {
    return this.saveFile(file, 'events');
  }

  /**
   * Process profile picture upload
   * @param {Object} file - Uploaded file object
   * @returns {Promise<string>} - File URL
   */
  async processProfilePicture(file) {
    return this.saveFile(file, 'profiles');
  }
}

module.exports = new UploadService();const AWS = require('aws-sdk');
const multer = require('multer');
const path = require('path');
const fs = require('fs');
const { v4: uuidv4 } = require('uuid');
const config = require('../config/config');
const logger = require('../utils/logger');

/**
 * Service for handling file uploads (profile pictures, event images)
 */
class UploadService {
  constructor() {
    this.storage = this.configureStorage();
    this.upload = multer({
      storage: this.storage,
      limits: {
        fileSize: 5 * 1024 * 1024, // 5MB limit
      },
      fileFilter: this.fileFilter
    });
    
    // Configure AWS S3 if enabled
    if (config.storage.type === 's3') {
      this.s3 = new AWS.S3({
        accessKeyId: config.storage.s3.accessKeyId,
        secretAccessKey: config.storage.s3.secretAccessKey,
        region: config.storage.s3.region
      });
    }
  }

  /**
   * Configure storage based on config
   * @returns {multer.StorageEngine} - Configured storage engine
   */
  configureStorage() {
    if (config.storage.type === 'local') {
      // Local storage
      return multer.diskStorage({
        destination: (req, file, cb) => {
          const uploadDir = config.storage.local.uploadDir;
          // Create directory if it doesn't exist
          if (!fs.existsSync(uploadDir)) {
            fs.mkdirSync(uploadDir, { recursive: true });
          }
          cb(null, uploadDir);
        },
        filename: (req, file, cb) => {
          const uniqueName = `${uuidv4()}${path.extname(file.originalname)}`;
          cb(null, uniqueName);
        }
      });
    } else {
      // For S3, use memory storage
      return multer.memoryStorage();
    }
  }

  /**
   * Filter files by type
   * @param {Object} req - Express request object
   * @param {Object} file - Uploaded file object
   * @param {Function} cb - Callback function
   */
  fileFilter(req, file, cb) {
    // Allow only images
    const allowedTypes = /jpeg|jpg|png|gif/;
    const extname = allowedTypes.test(path.extname(file.originalname).toLowerCase());
    const mimetype = allowedTypes.test(file.mimetype);
    
    if (extname && mimetype) {
      return cb(null, true);
    } else {
      cb(new Error('Only image files are allowed!'));
    }
  }

  /**
   * Get multer middleware for specific field
   * @param {string} fieldName - Form field name
   * @returns {Function} - Multer middleware
   */
  getUploadMiddleware(fieldName) {
    return this.upload.single(fieldName);
  }

  /**
   * Upload file to S3
   * @param {Object} file - File object from multer
   * @param {string} folder - Folder name in S3
   * @returns {Promise<string>} - File URL
   */
  async uploadToS3(file, folder = '') {
    try {
      const uniqueName = `${folder}/${uuidv4()}${path.extname(file.originalname)}`;
      
      const params = {
        Bucket: config.storage.s3.bucket,
        Key: uniqueName,
        Body: file.buffer,
        ContentType: file.mimetype,
        ACL: 'public-read'
      };
      
      const result = await this.s3.upload(params).promise();
      logger.info(`File uploaded to S3: ${result.Location}`);
      return result.Location;
    } catch (error) {
      logger.error('Error uploading to S3:', error);
      throw error;
    }
  }

  /**
   * Save file to local storage or S3
   * @param {Object} file - File object from multer
   * @param {string} folder - Folder name
   * @returns {Promise<string>} - File URL or path
   */
  async saveFile(file, folder = '') {
    if (!file) {
      throw new Error('No file provided');
    }
    
    if (config.storage.type === 's3') {
      return await this.uploadToS3(file, folder);
    } else {
      // For local storage, file already saved by multer
      return `${config.baseUrl}/uploads/${file.filename}`;
    }
  }

  /**
   * Delete file from storage
   * @param {string} fileUrl - URL or path of the file
   * @returns {Promise<boolean>} - Success status
   */
  async deleteFile(fileUrl) {
    try {
      if (config.storage.type === 's3') {
        // Extract key from URL
        const key = fileUrl.split('/').slice(3).join('/');
        
        const params = {
          Bucket: config.storage.s3.bucket,
          Key: key
        };
        
        await this.s3.deleteObject(params).promise();
        logger.info(`File deleted from S3: ${key}`);
        return true;
      } else {
        // For local storage
        const filePath = path.join(
          config.storage.local.uploadDir,
          path.basename(fileUrl)
        );
        
        if (fs.existsSync(filePath)) {
          fs.unlinkSync(filePath);
          logger.info(`File deleted from local storage: ${filePath}`);
          return true;
        }
        return false;
      }
    } catch (error) {
      logger.error('Error deleting file:', error);
      return false;
    }
  }

  /**
   * Process event image upload
   * @param {Object} file - Uploaded file object
   * @returns {Promise<string>} - File URL
   */
  async processEventImage(file) {
    return this.saveFile(file, 'events');
  }

  /**
   * Process profile picture upload
   * @param {Object} file - Uploaded file object
   * @returns {Promise<string>} - File URL
   */
  async processProfilePicture(file) {
    return this.saveFile(file, 'profiles');
  }
}

module.exports = new UploadService();
</file>

<file path="backend/utils/logger.js">
const winston = require('winston');
require('dotenv').config();

// Define log levels
const levels = {
  error: 0,
  warn: 1,
  info: 2,
  http: 3,
  debug: 4
};

// Define log colors
const colors = {
  error: 'red',
  warn: 'yellow',
  info: 'green',
  http: 'magenta',
  debug: 'blue'
};

// Add colors to winston
winston.addColors(colors);

// Create format
const format = winston.format.combine(
  winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
  winston.format.printf(
    info => `${info.timestamp} ${info.level}: ${info.message}`
  )
);

// Define which transports to use
const transports = [
  // Console transport
  new winston.transports.Console({
    format: winston.format.combine(
      winston.format.colorize({ all: true }),
      format
    )
  }),
  // File transport for errors
  new winston.transports.File({
    filename: 'logs/error.log',
    level: 'error'
  }),
  // File transport for all logs
  new winston.transports.File({ filename: 'logs/all.log' })
];

// Create logger
const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  levels,
  format,
  transports
});

module.exports = logger;
</file>

<file path=".gitignore">
.qodo
</file>

<file path="backend/api/controllers/userController.js">
const db = require('../../config/database');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');

// Use direct exports at the bottom instead of exporting functions individually
const register = async (req, res) => {
  try {
    const { username, email, password, bio } = req.body;
    
    // Hash password
    const salt = await bcrypt.genSalt(10);
    const hashedPassword = await bcrypt.hash(password, salt);
    
    // Check if user already exists
    const [existingUsers] = await db.query(
      'SELECT * FROM users WHERE username = ? OR email = ?',
      [username, email]
    );
    
    if (existingUsers.length > 0) {
      return res.status(400).json({ message: 'Username or email already exists' });
    }
    
    // Insert new user
    const [result] = await db.query(
      'INSERT INTO users (username, email, password, bio) VALUES (?, ?, ?, ?)',
      [username, email, hashedPassword, bio || null]
    );
    
    // Generate token
    const token = jwt.sign(
      { id: result.insertId, username, isAdmin: false },
      process.env.JWT_SECRET,
      { expiresIn: '24h' }
    );
    
    res.status(201).json({
      message: 'User registered successfully',
      token,
      user: {
        id: result.insertId,
        username,
        email,
        bio: bio || null,
        isAdmin: false
      }
    });
  } catch (error) {
    console.error('Registration error:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

const login = async (req, res) => {
  try {
    const { email, password } = req.body;
    
    // Find user by email
    const [users] = await db.query('SELECT * FROM users WHERE email = ?', [email]);
    
    if (users.length === 0) {
      return res.status(401).json({ message: 'Invalid credentials' });
    }
    
    const user = users[0];
    
    // Check password
    const isMatch = await bcrypt.compare(password, user.password);
    
    if (!isMatch) {
      return res.status(401).json({ message: 'Invalid credentials' });
    }
    
    // Generate token
    const token = jwt.sign(
      { id: user.id, username: user.username, isAdmin: user.is_admin },
      process.env.JWT_SECRET,
      { expiresIn: '24h' }
    );
    
    res.json({
      message: 'Login successful',
      token,
      user: {
        id: user.id,
        username: user.username,
        email: user.email,
        bio: user.bio,
        profilePic: user.profile_pic,
        isAdmin: user.is_admin
      }
    });
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

const getProfile = async (req, res) => {
  try {
    const userId = req.user.id;
    
    const [users] = await db.query('SELECT id, username, email, profile_pic, bio, is_admin, created_at FROM users WHERE id = ?', [userId]);
    
    if (users.length === 0) {
      return res.status(404).json({ message: 'User not found' });
    }
    
    const user = users[0];
    
    res.json({
      id: user.id,
      username: user.username,
      email: user.email,
      profilePic: user.profile_pic,
      bio: user.bio,
      isAdmin: user.is_admin,
      createdAt: user.created_at
    });
  } catch (error) {
    console.error('Get profile error:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

const updateUserProfile = async (req, res) => {
  try {
    const userId = req.user.id;
    const { username, email, bio } = req.body;
    let profilePic = null;
    
    // If there's a file upload, get the path
    if (req.file) {
      profilePic = req.file.path;
    }
    
    // Check if username or email already exists for other users
    if (username || email) {
      const [existingUsers] = await db.query(
        'SELECT * FROM users WHERE (username = ? OR email = ?) AND id != ?',
        [username || '', email || '', userId]
      );
      
      if (existingUsers.length > 0) {
        return res.status(400).json({ message: 'Username or email already in use' });
      }
    }
    
    // Construct update query dynamically
    let updateFields = [];
    let queryParams = [];
    
    if (username) {
      updateFields.push('username = ?');
      queryParams.push(username);
    }
    
    if (email) {
      updateFields.push('email = ?');
      queryParams.push(email);
    }
    
    if (bio !== undefined) {
      updateFields.push('bio = ?');
      queryParams.push(bio);
    }
    
    if (profilePic) {
      updateFields.push('profile_pic = ?');
      queryParams.push(profilePic);
    }
    
    if (updateFields.length === 0) {
      return res.status(400).json({ message: 'No fields to update' });
    }
    
    // Add userId to params
    queryParams.push(userId);
    
    const query = `UPDATE users SET ${updateFields.join(', ')} WHERE id = ?`;
    
    await db.query(query, queryParams);
    
    res.json({ message: 'Profile updated successfully' });
  } catch (error) {
    console.error('Update profile error:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

const getPublicUserProfile = async (req, res) => {
  try {
    const { id } = req.params;
    
    const [users] = await db.query(
      'SELECT id, username, bio, profile_pic, created_at FROM users WHERE id = ?',
      [id]
    );
    
    if (users.length === 0) {
      return res.status(404).json({ message: 'User not found' });
    }
    
    res.json(users[0]);
  } catch (error) {
    console.error('Get user error:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

const deleteAccount = async (req, res) => {
  try {
    const userId = req.user.id;
    
    // Delete user - cascade will handle related records
    await db.query('DELETE FROM users WHERE id = ?', [userId]);
    
    res.json({ message: 'Account deleted successfully' });
  } catch (error) {
    console.error('Delete account error:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

const getAllUsers = async (req, res) => {
  try {
    if (!req.user.isAdmin) {
      return res.status(403).json({ message: 'Access denied' });
    }
    
    const [users] = await db.query(
      'SELECT id, username, email, profile_pic, bio, is_admin, created_at FROM users'
    );
    
    res.json(users);
  } catch (error) {
    console.error('Get all users error:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

const adminUpdateUser = async (req, res) => {
  try {
    if (!req.user.isAdmin) {
      return res.status(403).json({ message: 'Access denied' });
    }
    
    const { id } = req.params;
    const { isAdmin, username, email, bio } = req.body;
    
    // Construct update query dynamically
    let updateFields = [];
    let queryParams = [];
    
    if (isAdmin !== undefined) {
      updateFields.push('is_admin = ?');
      queryParams.push(isAdmin);
    }
    
    if (username) {
      updateFields.push('username = ?');
      queryParams.push(username);
    }
    
    if (email) {
      updateFields.push('email = ?');
      queryParams.push(email);
    }
    
    if (bio !== undefined) {
      updateFields.push('bio = ?');
      queryParams.push(bio);
    }
    
    if (updateFields.length === 0) {
      return res.status(400).json({ message: 'No fields to update' });
    }
    
    // Add userId to params
    queryParams.push(id);
    
    const query = `UPDATE users SET ${updateFields.join(', ')} WHERE id = ?`;
    
    await db.query(query, queryParams);
    
    res.json({ message: 'User updated successfully' });
  } catch (error) {
    console.error('Admin update user error:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

const forgotPassword = async (req, res) => {
  try {
    const { email } = req.body;
    
    // Check if user exists
    const [users] = await db.query('SELECT id FROM users WHERE email = ?', [email]);
    
    if (users.length === 0) {
      // For security reasons, don't reveal if email exists or not
      return res.json({ message: 'If your email is registered, you will receive a password reset link' });
    }
    
    // Generate a reset token
    const resetToken = jwt.sign(
      { id: users[0].id, purpose: 'password-reset' },
      process.env.JWT_SECRET,
      { expiresIn: '1h' }
    );
    
    // In a real application, you would send an email with the reset link
    // For this implementation, we'll just return the token
    
    // Store token in database (optional, depends on your implementation)
    await db.query(
      'UPDATE users SET reset_token = ?, reset_token_expires = DATE_ADD(NOW(), INTERVAL 1 HOUR) WHERE id = ?',
      [resetToken, users[0].id]
    );
    
    res.json({ 
      message: 'If your email is registered, you will receive a password reset link',
      // In a real application, you would NOT return the token to the API response
      // This is just for demonstration purposes
      resetToken 
    });
  } catch (error) {
    console.error('Forgot password error:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

const resetPassword = async (req, res) => {
  try {
    const { token, newPassword } = req.body;
    
    // Verify token
    let decoded;
    try {
      decoded = jwt.verify(token, process.env.JWT_SECRET);
      
      // Check if the token was created for password reset
      if (decoded.purpose !== 'password-reset') {
        return res.status(400).json({ message: 'Invalid token' });
      }
    } catch (err) {
      return res.status(400).json({ message: 'Invalid or expired token' });
    }
    
    // Check if token exists in database (optional)
    const [users] = await db.query(
      'SELECT id FROM users WHERE id = ? AND reset_token = ? AND reset_token_expires > NOW()',
      [decoded.id, token]
    );
    
    if (users.length === 0) {
      return res.status(400).json({ message: 'Invalid or expired token' });
    }
    
    // Hash new password
    const salt = await bcrypt.genSalt(10);
    const hashedPassword = await bcrypt.hash(newPassword, salt);
    
    // Update password and clear reset token
    await db.query(
      'UPDATE users SET password = ?, reset_token = NULL, reset_token_expires = NULL WHERE id = ?',
      [hashedPassword, decoded.id]
    );
    
    res.json({ message: 'Password has been reset successfully' });
  } catch (error) {
    console.error('Reset password error:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

const adminDeleteUser = async (req, res) => {
  try {
    if (!req.user.isAdmin) {
      return res.status(403).json({ message: 'Access denied' });
    }
    
    const { id } = req.params;
    
    // Check if the user exists
    const [users] = await db.query('SELECT id FROM users WHERE id = ?', [id]);
    
    if (users.length === 0) {
      return res.status(404).json({ message: 'User not found' });
    }
    
    // Delete user - cascade will handle related records
    await db.query('DELETE FROM users WHERE id = ?', [id]);
    
    res.json({ message: 'User deleted successfully' });
  } catch (error) {
    console.error('Admin delete user error:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

// Export all functions
module.exports = {
  register,
  login,
  getProfile,
  updateUserProfile,
  getPublicUserProfile,
  deleteAccount,
  getAllUsers,
  adminUpdateUser,
  forgotPassword,
  resetPassword,
  adminDeleteUser
};
</file>

<file path="backend/package.json">
{
  "name": "backend",
  "version": "1.0.0",
  "description": "",
  "main": "server.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "dev": "node server.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "commonjs",
  "dependencies": {
    "axios": "^1.8.3",
    "bcryptjs": "^3.0.2",
    "compression": "^1.8.0",
    "cors": "^2.8.5",
    "dotenv": "^16.4.7",
    "express": "^4.21.2",
    "express-rate-limit": "^7.5.0",
    "express-validator": "^7.2.1",
    "helmet": "^8.0.0",
    "jsonwebtoken": "^9.0.2",
    "morgan": "^1.10.0",
    "multer": "^1.4.5-lts.1",
    "mysql2": "^3.13.0",
    "winston": "^3.17.0"
  }
}
</file>

</files>
