This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
backend/.env
backend/.gitignore
backend/api/middleware/auth.js
backend/api/middleware/errorHandler.js
backend/api/middleware/validation.js
backend/api/models/calendarModel.js
backend/api/models/categoryModel.js
backend/api/models/eventModel.js
backend/api/models/notificationModel.js
backend/api/models/recommendationModel.js
backend/api/models/reviewModel.js
backend/api/models/userModel.js
backend/config/config.js
backend/config/database.js
backend/package.json
backend/server.js
backend/service/ai.service.js
backend/utils/helpers.js
backend/utils/logger.js
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="backend/.env">
# Server Configuration
PORT=3000
NODE_ENV=development

# Database Configuration
DB_HOST=localhost
DB_USER=root
DB_PASS=Nyandana@23!
DB_NAME=eventreviews

# JWT Configuration
JWT_SECRET=3d6f1a7e9c4b1e6e9f1a2c5b7d8e3a9f1c4b6d7e9f1a3b5c6d7e8f9a2b3c4d6
JWT_EXPIRES_IN=24h

# Claude AI API Configuration
CLAUDE_API_KEY=your_claude_api_key
CLAUDE_API_URL=https://api.anthropic.com/v1/messages

# File Upload Configuration
UPLOAD_PATH=./uploads
MAX_FILE_SIZE=5242880

# Email Configuration
EMAIL_HOST=smtp.example.com
EMAIL_PORT=587
EMAIL_USER=siphelosp2nyands@gmail.com
EMAIL_PASS=Nyandana@23!
</file>

<file path="backend/.gitignore">
.qodo
backend\node_modules
</file>

<file path="backend/api/middleware/auth.js">
const jwt = require('jsonwebtoken');
const config = require('../../config/config');
const { ApiError } = require('./errorHandler');
const db = require('../../config/database');

/**
 * Middleware to protect routes that require authentication
 */
exports.protect = async (req, res, next) => {
  let token;

  // Check if token exists in headers
  if (req.headers.authorization && req.headers.authorization.startsWith('Bearer')) {
    token = req.headers.authorization.split(' ')[1];
  }

  // Check if token exists
  if (!token) {
    return next(new ApiError('Not authorized to access this route', 401));
  }

  try {
    // Verify token
    const decoded = jwt.verify(token, config.app.jwtSecret);

    // Check if user still exists
    const [user] = await db.query(
      'SELECT id, username, email, is_admin FROM users WHERE id = ?',
      [decoded.id]
    );

    if (!user) {
      return next(new ApiError('The user belonging to this token no longer exists', 401));
    }

    // Add user to request object
    req.user = user;
    next();
  } catch (error) {
    return next(new ApiError('Not authorized to access this route', 401));
  }
};

/**
 * Middleware to restrict access to admin users
 */
exports.admin = (req, res, next) => {
  if (!req.user || !req.user.is_admin) {
    return next(new ApiError('Access denied. Admin privileges required', 403));
  }
  next();
};

/**
 * Middleware to check if user can modify a resource
 * @param {string} model - The database model to check (e.g., 'events', 'reviews')
 * @param {string} paramName - The request parameter containing the resource ID (e.g., 'id')
 * @param {string} ownerField - The field in the model representing the owner (e.g., 'user_id', 'organizer_id')
 */
exports.checkOwnership = (model, paramName, ownerField) => {
  return async (req, res, next) => {
    try {
      // If user is admin, allow access
      if (req.user.is_admin) {
        return next();
      }

      const resourceId = req.params[paramName];
      
      // Check if resource exists and belongs to user
      const [resource] = await db.query(
        `SELECT ${ownerField} FROM ${model} WHERE id = ?`,
        [resourceId]
      );

      if (!resource) {
        return next(new ApiError(`${model.slice(0, -1)} not found`, 404));
      }

      // Check if user owns the resource
      if (resource[ownerField] !== req.user.id) {
        return next(new ApiError('Not authorized to modify this resource', 403));
      }

      next();
    } catch (error) {
      next(error);
    }
  };
};
</file>

<file path="backend/api/middleware/errorHandler.js">
const { logger } = require('../../utils/logger');

/**
 * Global error handling middleware
 */
const errorHandler = (err, req, res, next) => {
  // Log the error
  logger.error(`${err.name}: ${err.message}`, { 
    method: req.method,
    url: req.url,
    body: req.body,
    stack: err.stack
  });

  // Error response object
  const error = {
    message: err.message || 'Server Error',
    status: err.statusCode || 500
  };

  // Add validation errors if available
  if (err.errors) {
    error.errors = err.errors;
  }

  // Add more detailed info in development
  if (process.env.NODE_ENV === 'development') {
    error.stack = err.stack;
  }

  res.status(error.status).json({
    success: false,
    error: error
  });
};

/**
 * Custom error class for API errors
 */
class ApiError extends Error {
  constructor(message, statusCode) {
    super(message);
    this.statusCode = statusCode;
    this.name = this.constructor.name;
    Error.captureStackTrace(this, this.constructor);
  }
}

/**
 * 404 Not Found error handler
 */
const notFound = (req, res, next) => {
  const error = new ApiError(`Not Found - ${req.originalUrl}`, 404);
  next(error);
};

module.exports = errorHandler;
module.exports.ApiError = ApiError;
module.exports.notFound = notFound;
</file>

<file path="backend/api/middleware/validation.js">
const { body, param, query, validationResult } = require('express-validator');
const { ApiError } = require('./errorHandler');

/**
 * Process validation results
 */
exports.validate = (req, res, next) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    const error = new ApiError('Validation error', 400);
    error.errors = errors.array().map(err => ({
      field: err.path,
      message: err.msg
    }));
    return next(error);
  }
  next();
};

/**
 * User validation rules
 */
exports.userRules = {
  // Create user validation
  createUser: [
    body('username')
      .trim()
      .isLength({ min: 3, max: 50 })
      .withMessage('Username must be between 3 and 50 characters'),
    body('email')
      .trim()
      .isEmail()
      .withMessage('Must be a valid email address'),
    body('password')
      .isLength({ min: 6 })
      .withMessage('Password must be at least 6 characters long')
  ],
  
  // Update user validation
  updateUser: [
    body('username')
      .optional()
      .trim()
      .isLength({ min: 3, max: 50 })
      .withMessage('Username must be between 3 and 50 characters'),
    body('email')
      .optional()
      .trim()
      .isEmail()
      .withMessage('Must be a valid email address'),
    body('bio')
      .optional()
      .isString()
      .withMessage('Bio must be a string')
  ],
  
  // Login validation
  login: [
    body('email')
      .trim()
      .isEmail()
      .withMessage('Must be a valid email address'),
    body('password')
      .exists()
      .withMessage('Password is required')
  ]
};

/**
 * Event validation rules
 */
exports.eventRules = {
  // Create event validation
  createEvent: [
    body('title')
      .trim()
      .isLength({ min: 5, max: 255 })
      .withMessage('Title must be between 5 and 255 characters'),
    body('description')
      .isString()
      .withMessage('Description must be a string')
      .isLength({ min: 10 })
      .withMessage('Description must be at least 10 characters'),
    body('date')
      .isDate()
      .withMessage('Date must be a valid date format (YYYY-MM-DD)'),
    body('time')
      .matches(/^([01]\d|2[0-3]):([0-5]\d)$/)
      .withMessage('Time must be in format HH:MM (24-hour)'),
    body('location')
      .trim()
      .isLength({ min: 5, max: 255 })
      .withMessage('Location must be between 5 and 255 characters'),
    body('categories')
      .isArray()
      .withMessage('Categories must be an array of category IDs')
  ],
  
  // Update event validation
  updateEvent: [
    body('title')
      .optional()
      .trim()
      .isLength({ min: 5, max: 255 })
      .withMessage('Title must be between 5 and 255 characters'),
    body('description')
      .optional()
      .isString()
      .withMessage('Description must be a string')
      .isLength({ min: 10 })
      .withMessage('Description must be at least 10 characters'),
    body('date')
      .optional()
      .isDate()
      .withMessage('Date must be a valid date format (YYYY-MM-DD)'),
    body('time')
      .optional()
      .matches(/^([01]\d|2[0-3]):([0-5]\d)$/)
      .withMessage('Time must be in format HH:MM (24-hour)'),
    body('location')
      .optional()
      .trim()
      .isLength({ min: 5, max: 255 })
      .withMessage('Location must be between 5 and 255 characters'),
    body('status')
      .optional()
      .isIn(['upcoming', 'ongoing', 'completed', 'cancelled'])
      .withMessage('Status must be one of: upcoming, ongoing, completed, cancelled'),
    body('categories')
      .optional()
      .isArray()
      .withMessage('Categories must be an array of category IDs')
  ]
};

/**
 * Review validation rules
 */
exports.reviewRules = {
  // Create review validation
  createReview: [
    body('event_id')
      .isInt({ min: 1 })
      .withMessage('Valid event ID is required'),
    body('rating')
      .isInt({ min: 1, max: 5 })
      .withMessage('Rating must be between 1 and 5'),
    body('content')
      .trim()
      .isLength({ min: 10 })
      .withMessage('Review content must be at least 10 characters')
  ],
  
  // Update review validation
  updateReview: [
    body('rating')
      .optional()
      .isInt({ min: 1, max: 5 })
      .withMessage('Rating must be between 1 and 5'),
    body('content')
      .optional()
      .trim()
      .isLength({ min: 10 })
      .withMessage('Review content must be at least 10 characters')
  ]
};

/**
 * Category validation rules
 */
exports.categoryRules = {
  // Create category validation
  createCategory: [
    body('name')
      .trim()
      .isLength({ min: 3, max: 100 })
      .withMessage('Category name must be between 3 and 100 characters'),
    body('description')
      .optional()
      .isString()
      .withMessage('Description must be a string')
  ],
  
  // Update category validation
  updateCategory: [
    body('name')
      .optional()
      .trim()
      .isLength({ min: 3, max: 100 })
      .withMessage('Category name must be between 3 and 100 characters'),
    body('description')
      .optional()
      .isString()
      .withMessage('Description must be a string')
  ]
};

/**
 * Calendar validation rules
 */
exports.calendarRules = {
  // Create calendar entry validation
  createCalendarEntry: [
    body('event_id')
      .isInt({ min: 1 })
      .withMessage('Valid event ID is required'),
    body('reminder_settings')
      .optional()
      .isJSON()
      .withMessage('Reminder settings must be valid JSON')
  ],
  
  // Update calendar entry validation
  updateCalendarEntry: [
    body('reminder_settings')
      .optional()
      .isJSON()
      .withMessage('Reminder settings must be valid JSON'),
    body('is_synced')
      .optional()
      .isBoolean()
      .withMessage('is_synced must be a boolean value')
  ]
};

/**
 * Common ID parameter validation
 */
exports.idParam = [
  param('id')
    .isInt({ min: 1 })
    .withMessage('ID parameter must be a positive integer')
];

/**
 * Pagination query parameters validation
 */
exports.paginationRules = [
  query('page')
    .optional()
    .isInt({ min: 1 })
    .withMessage('Page must be a positive integer'),
  query('limit')
    .optional()
    .isInt({ min: 1, max: 100 })
    .withMessage('Limit must be between 1 and 100')
];
</file>

<file path="backend/api/models/calendarModel.js">
// calendarModel.js
const db = require('../../config/database');

/**
 * Calendar model
 */
const Calendar = {
  /**
   * Add event to user's calendar
   * @param {Object} calendarData - Calendar data
   * @returns {Object} - Created calendar entry
   */
  async addEvent(calendarData) {
    try {
      // Define reminder settings JSON if provided
      let reminderSettings = null;
      if (calendarData.reminder_settings) {
        if (typeof calendarData.reminder_settings === 'string') {
          reminderSettings = calendarData.reminder_settings;
        } else {
          reminderSettings = JSON.stringify(calendarData.reminder_settings);
        }
      }

      // Insert calendar entry into database
      const result = await db.query(
        `INSERT INTO calendars (user_id, event_id, reminder_settings, is_synced) VALUES (?, ?, ?, ?)`,
        [
          calendarData.user_id,
          calendarData.event_id,
          reminderSettings,
          calendarData.is_synced || false
        ]
      );

      // Get the created calendar entry
      const [calendar] = await this.findById(result.insertId);
      return calendar;
    } catch (error) {
      throw error;
    }
  },

  /**
   * Find calendar entry by ID
   * @param {number} id - Calendar ID
   * @returns {Object} - Calendar object
   */
  async findById(id) {
    return await db.query(
      `SELECT c.*, e.title as event_title, e.date as event_date, e.time as event_time
       FROM calendars c
       JOIN events e ON c.event_id = e.id
       WHERE c.id = ?`,
      [id]
    );
  },

  /**
   * Find calendar entry by user and event
   * @param {number} userId - User ID
   * @param {number} eventId - Event ID
   * @returns {Object} - Calendar object
   */
  async findByUserAndEvent(userId, eventId) {
    return await db.query(
      `SELECT c.*, e.title as event_title, e.date as event_date, e.time as event_time
       FROM calendars c
       JOIN events e ON c.event_id = e.id
       WHERE c.user_id = ? AND c.event_id = ?`,
      [userId, eventId]
    );
  },

  /**
   * Update calendar entry
   * @param {number} id - Calendar ID
   * @param {Object} calendarData - Calendar data to update
   * @returns {Object} - Updated calendar object
   */
  async update(id, calendarData) {
    // Create dynamic update query based on provided fields
    const fields = [];
    const values = [];

    if (calendarData.reminder_settings) {
      let reminderSettings = null;
      if (typeof calendarData.reminder_settings === 'string') {
        reminderSettings = calendarData.reminder_settings;
      } else {
        reminderSettings = JSON.stringify(calendarData.reminder_settings);
      }
      
      fields.push('reminder_settings = ?');
      values.push(reminderSettings);
    }
    
    if (calendarData.is_synced !== undefined) {
      fields.push('is_synced = ?');
      values.push(calendarData.is_synced);
    }

    // Only proceed if there are fields to update
    if (fields.length === 0) {
      return await this.findById(id);
    }

    // Add ID to values array
    values.push(id);

    // Execute update query
    await db.query(
      `UPDATE calendars SET ${fields.join(', ')} WHERE id = ?`,
      values
    );

    // Return updated calendar entry
    const [updatedCalendar] = await this.findById(id);
    return updatedCalendar;
  },

  /**
   * Remove event from user's calendar
   * @param {number} id - Calendar ID
   * @returns {boolean} - Success status
   */
  async removeEvent(id) {
    const result = await db.query('DELETE FROM calendars WHERE id = ?', [id]);
    return result.affectedRows > 0;
  },

  /**
   * Get user's calendar events
   * @param {number} userId - User ID
   * @param {Object} options - Query options (limit, offset, filter)
   * @returns {Array} - Array of calendar objects
   */
  async getUserEvents(userId, options = { limit: 10, offset: 0, filter: {} }) {
    let query = `SELECT c.*, e.title, e.description, e.date, e.time, e.location, e.status, e.image
                 FROM calendars c
                 JOIN events e ON c.event_id = e.id
                 WHERE c.user_id = ?`;
    
    const queryParams = [userId];
    
    // Add filter conditions
    if (options.filter) {
      if (options.filter.dateFrom) {
        query += ' AND e.date >= ?';
        queryParams.push(options.filter.dateFrom);
      }
      
      if (options.filter.dateTo) {
        query += ' AND e.date <= ?';
        queryParams.push(options.filter.dateTo);
      }
      
      if (options.filter.status) {
        query += ' AND e.status = ?';
        queryParams.push(options.filter.status);
      }
    }
    
    // Add sorting and pagination
    query += ' ORDER BY e.date ASC, e.time ASC LIMIT ? OFFSET ?';
    queryParams.push(options.limit, options.offset);
    
    return await db.query(query, queryParams);
  },

  /**
   * Get upcoming events for reminder
   * @param {number} minutesAhead - Minutes ahead to look for events
   * @returns {Array} - Array of calendar objects with events coming up
   */
  async getUpcomingEvents(minutesAhead = 60) {
    const now = new Date();
    const targetDate = new Date(now.getTime() + minutesAhead * 60000);
    
    return await db.query(
      `SELECT c.*, e.title, e.date, e.time, e.location, u.email as user_email, u.username as user_name
       FROM calendars c
       JOIN events e ON c.event_id = e.id
       JOIN users u ON c.user_id = u.id
       WHERE e.date = CURDATE() 
       AND TIME_TO_SEC(TIMEDIFF(e.time, CURTIME())) BETWEEN 0 AND ?
       AND JSON_EXTRACT(c.reminder_settings, '$.enabled') = TRUE`,
      [minutesAhead * 60]
    );
  },

  /**
   * Check if user has added event to calendar
   * @param {number} userId - User ID
   * @param {number} eventId - Event ID
   * @returns {boolean} - True if event is in user's calendar
   */
  async hasEvent(userId, eventId) {
    const [result] = await db.query(
      `SELECT COUNT(*) as count
       FROM calendars
       WHERE user_id = ? AND event_id = ?`,
      [userId, eventId]
    );
    
    return result.count > 0;
  }
};

module.exports = Calendar;
</file>

<file path="backend/api/models/categoryModel.js">
// categoryModel.js
const db = require('../../config/database');

/**
 * Category model
 */
const Category = {
  /**
   * Create a new category
   * @param {Object} categoryData - Category data
   * @returns {Object} - Created category object
   */
  async create(categoryData) {
    try {
      // Insert category into database
      const result = await db.query(
        `INSERT INTO categories (name, description) VALUES (?, ?)`,
        [categoryData.name, categoryData.description || null]
      );

      // Get the created category
      const [category] = await this.findById(result.insertId);
      return category;
    } catch (error) {
      throw error;
    }
  },

  /**
   * Find category by ID
   * @param {number} id - Category ID
   * @returns {Object} - Category object
   */
  async findById(id) {
    return await db.query(
      `SELECT * FROM categories WHERE id = ?`,
      [id]
    );
  },

  /**
   * Find category by name
   * @param {string} name - Category name
   * @returns {Object} - Category object
   */
  async findByName(name) {
    return await db.query(
      `SELECT * FROM categories WHERE name = ?`,
      [name]
    );
  },

  /**
   * Update category
   * @param {number} id - Category ID
   * @param {Object} categoryData - Category data to update
   * @returns {Object} - Updated category object
   */
  async update(id, categoryData) {
    // Create dynamic update query based on provided fields
    const fields = [];
    const values = [];

    if (categoryData.name) {
      fields.push('name = ?');
      values.push(categoryData.name);
    }
    if (categoryData.description) {
      fields.push('description = ?');
      values.push(categoryData.description);
    }

    // Only proceed if there are fields to update
    if (fields.length === 0) {
      return await this.findById(id);
    }

    // Add ID to values array
    values.push(id);

    // Execute update query
    await db.query(
      `UPDATE categories SET ${fields.join(', ')} WHERE id = ?`,
      values
    );

    // Return updated category
    const [updatedCategory] = await this.findById(id);
    return updatedCategory;
  },

  /**
   * Delete category
   * @param {number} id - Category ID
   * @returns {boolean} - Success status
   */
  async delete(id) {
    const result = await db.query('DELETE FROM categories WHERE id = ?', [id]);
    return result.affectedRows > 0;
  },

  /**
   * Get all categories
   * @returns {Array} - Array of category objects
   */
  async getAll() {
    return await db.query('SELECT * FROM categories ORDER BY name ASC');
  },

  /**
   * Get categories with event count
   * @returns {Array} - Array of category objects with event count
   */
  async getAllWithEventCount() {
    return await db.query(
      `SELECT c.*, COUNT(ec.event_id) as event_count
       FROM categories c
       LEFT JOIN event_categories ec ON c.id = ec.category_id
       GROUP BY c.id
       ORDER BY c.name ASC`
    );
  },

  /**
   * Get popular categories
   * @param {number} limit - Number of categories to return
   * @returns {Array} - Array of popular category objects
   */
  async getPopular(limit = 5) {
    return await db.query(
      `SELECT c.*, COUNT(ec.event_id) as event_count
       FROM categories c
       JOIN event_categories ec ON c.id = ec.category_id
       GROUP BY c.id
       ORDER BY event_count DESC
       LIMIT ?`,
      [limit]
    );
  }
};

module.exports = Category;
</file>

<file path="backend/api/models/eventModel.js">
// eventModel.js
const db = require('../../config/database');

/**
 * Event model
 */
const Event = {
  /**
   * Create a new event
   * @param {Object} eventData - Event data
   * @returns {Object} - Created event object
   */
  async create(eventData) {
    try {
      // Insert event into database
      const result = await db.query(
        `INSERT INTO events (title, description, date, time, location, organizer_id, image, status) 
         VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
        [
          eventData.title,
          eventData.description,
          eventData.date,
          eventData.time,
          eventData.location,
          eventData.organizer_id,
          eventData.image || null,
          eventData.status || 'upcoming'
        ]
      );

      const eventId = result.insertId;

      // Add event categories if provided
      if (eventData.categories && eventData.categories.length > 0) {
        const categoryValues = eventData.categories.map(categoryId => [eventId, categoryId]);
        await db.query(
          `INSERT INTO event_categories (event_id, category_id) VALUES ?`,
          [categoryValues]
        );
      }

      // Get the created event
      const [event] = await this.findById(eventId);
      return event;
    } catch (error) {
      throw error;
    }
  },

  /**
   * Find event by ID
   * @param {number} id - Event ID
   * @returns {Object} - Event object
   */
  async findById(id) {
    const [event] = await db.query(
      `SELECT * FROM events WHERE id = ?`,
      [id]
    );
    
    if (event) {
      // Get event categories
      event.categories = await this.getEventCategories(id);
    }
    
    return event;
  },

  /**
   * Get event categories
   * @param {number} eventId - Event ID
   * @returns {Array} - Array of category objects
   */
  async getEventCategories(eventId) {
    return await db.query(
      `SELECT c.* FROM categories c
       JOIN event_categories ec ON c.id = ec.category_id
       WHERE ec.event_id = ?`,
      [eventId]
    );
  },

  /**
   * Update event
   * @param {number} id - Event ID
   * @param {Object} eventData - Event data to update
   * @returns {Object} - Updated event object
   */
  async update(id, eventData) {
    // Create dynamic update query based on provided fields
    const fields = [];
    const values = [];

    if (eventData.title) {
      fields.push('title = ?');
      values.push(eventData.title);
    }
    if (eventData.description) {
      fields.push('description = ?');
      values.push(eventData.description);
    }
    if (eventData.date) {
      fields.push('date = ?');
      values.push(eventData.date);
    }
    if (eventData.time) {
      fields.push('time = ?');
      values.push(eventData.time);
    }
    if (eventData.location) {
      fields.push('location = ?');
      values.push(eventData.location);
    }
    if (eventData.image) {
      fields.push('image = ?');
      values.push(eventData.image);
    }
    if (eventData.status) {
      fields.push('status = ?');
      values.push(eventData.status);
    }

    // Only proceed if there are fields to update
    if (fields.length === 0) {
      return await this.findById(id);
    }

    // Add ID to values array
    values.push(id);

    // Execute update query
    await db.query(
      `UPDATE events SET ${fields.join(', ')} WHERE id = ?`,
      values
    );

    // Update categories if provided
    if (eventData.categories && eventData.categories.length > 0) {
      // Remove existing categories
      await db.query('DELETE FROM event_categories WHERE event_id = ?', [id]);
      
      // Add new categories
      const categoryValues = eventData.categories.map(categoryId => [id, categoryId]);
      await db.query(
        `INSERT INTO event_categories (event_id, category_id) VALUES ?`,
        [categoryValues]
      );
    }

    // Return updated event
    const [updatedEvent] = await this.findById(id);
    return updatedEvent;
  },

  /**
   * Delete event
   * @param {number} id - Event ID
   * @returns {boolean} - Success status
   */
  async delete(id) {
    const result = await db.query('DELETE FROM events WHERE id = ?', [id]);
    return result.affectedRows > 0;
  },

  /**
   * Get all events
   * @param {Object} options - Query options (limit, offset, filter, sort)
   * @returns {Array} - Array of event objects
   */
  async getAll(options = { limit: 10, offset: 0, filter: {}, sort: { by: 'date', order: 'ASC' } }) {
    let query = `SELECT * FROM events`;
    const queryParams = [];
    
    // Add filter conditions
    if (options.filter) {
      const filterConditions = [];
      
      if (options.filter.status) {
        filterConditions.push('status = ?');
        queryParams.push(options.filter.status);
      }
      
      if (options.filter.organizer_id) {
        filterConditions.push('organizer_id = ?');
        queryParams.push(options.filter.organizer_id);
      }
      
      if (options.filter.dateFrom) {
        filterConditions.push('date >= ?');
        queryParams.push(options.filter.dateFrom);
      }
      
      if (options.filter.dateTo) {
        filterConditions.push('date <= ?');
        queryParams.push(options.filter.dateTo);
      }
      
      if (options.filter.search) {
        filterConditions.push('(title LIKE ? OR description LIKE ? OR location LIKE ?)');
        const searchTerm = `%${options.filter.search}%`;
        queryParams.push(searchTerm, searchTerm, searchTerm);
      }
      
      if (filterConditions.length > 0) {
        query += ` WHERE ${filterConditions.join(' AND ')}`;
      }
    }
    
    // Add sorting
    if (options.sort) {
      query += ` ORDER BY ${options.sort.by} ${options.sort.order}`;
    }
    
    // Add pagination
    query += ` LIMIT ? OFFSET ?`;
    queryParams.push(options.limit, options.offset);
    
    const events = await db.query(query, queryParams);
    
    // Get categories for each event
    for (const event of events) {
      event.categories = await this.getEventCategories(event.id);
    }
    
    return events;
  },

  /**
   * Get events by category
   * @param {number} categoryId - Category ID
   * @param {Object} options - Query options (limit, offset)
   * @returns {Array} - Array of event objects
   */
  async getByCategory(categoryId, options = { limit: 10, offset: 0 }) {
    const events = await db.query(
      `SELECT e.* FROM events e
       JOIN event_categories ec ON e.id = ec.event_id
       WHERE ec.category_id = ?
       ORDER BY e.date ASC
       LIMIT ? OFFSET ?`,
      [categoryId, options.limit, options.offset]
    );
    
    // Get categories for each event
    for (const event of events) {
      event.categories = await this.getEventCategories(event.id);
    }
    
    return events;
  },

  /**
   * Update event rating
   * @param {number} eventId - Event ID
   * @returns {boolean} - Success status
   */
  async updateRating(eventId) {
    const [ratingResult] = await db.query(
      `SELECT AVG(rating) as avg_rating FROM reviews WHERE event_id = ?`,
      [eventId]
    );
    
    if (ratingResult && ratingResult.avg_rating !== null) {
      await db.query(
        `UPDATE events SET avg_rating = ? WHERE id = ?`,
        [ratingResult.avg_rating, eventId]
      );
      return true;
    }
    return false;
  },

  /**
   * Count events
   * @param {Object} filter - Filter options
   * @returns {number} - Total number of events
   */
  async count(filter = {}) {
    let query = `SELECT COUNT(*) as total FROM events`;
    const queryParams = [];
    
    // Add filter conditions
    if (filter) {
      const filterConditions = [];
      
      if (filter.status) {
        filterConditions.push('status = ?');
        queryParams.push(filter.status);
      }
      
      if (filter.organizer_id) {
        filterConditions.push('organizer_id = ?');
        queryParams.push(filter.organizer_id);
      }
      
      if (filterConditions.length > 0) {
        query += ` WHERE ${filterConditions.join(' AND ')}`;
      }
    }
    
    const [result] = await db.query(query, queryParams);
    return result.total;
  }
};

module.exports = Event;
</file>

<file path="backend/api/models/notificationModel.js">
// notificationModel.js
const db = require('../../config/database');

/**
 * Notification model
 */
const Notification = {
  /**
   * Create a new notification
   * @param {Object} notificationData - Notification data
   * @returns {Object} - Created notification object
   */
  async create(notificationData) {
    try {
      // Insert notification into database
      const result = await db.query(
        `INSERT INTO notifications (user_id, content, type, related_id) VALUES (?, ?, ?, ?)`,
        [
          notificationData.user_id,
          notificationData.content,
          notificationData.type,
          notificationData.related_id || null
        ]
      );

      // Get the created notification
      const [notification] = await this.findById(result.insertId);
      return notification;
    } catch (error) {
      throw error;
    }
  },

  /**
   * Find notification by ID
   * @param {number} id - Notification ID
   * @returns {Object} - Notification object
   */
  async findById(id) {
    return await db.query(
      `SELECT * FROM notifications WHERE id = ?`,
      [id]
    );
  },

  /**
   * Mark notification as read
   * @param {number} id - Notification ID
   * @returns {boolean} - Success status
   */
  async markAsRead(id) {
    const result = await db.query(
      `UPDATE notifications SET read_status = TRUE WHERE id = ?`,
      [id]
    );
    
    return result.affectedRows > 0;
  },

  /**
   * Mark all user notifications as read
   * @param {number} userId - User ID
   * @returns {boolean} - Success status
   */
  async markAllAsRead(userId) {
    const result = await db.query(
      `UPDATE notifications SET read_status = TRUE WHERE user_id = ? AND read_status = FALSE`,
      [userId]
    );
    
    return result.affectedRows > 0;
  },

  /**
   * Delete notification
   * @param {number} id - Notification ID
   * @returns {boolean} - Success status
   */
  async delete(id) {
    const result = await db.query('DELETE FROM notifications WHERE id = ?', [id]);
    return result.affectedRows > 0;
  },

  /**
   * Get user notifications
   * @param {number} userId - User ID
   * @param {Object} options - Query options (limit, offset, unreadOnly)
   * @returns {Array} - Array of notification objects
   */
  async getUserNotifications(userId, options = { limit: 10, offset: 0, unreadOnly: false }) {
    let query = `SELECT * FROM notifications WHERE user_id = ?`;
    
    const queryParams = [userId];
    
    if (options.unreadOnly) {
      query += ' AND read_status = FALSE';
    }
    
    query += ' ORDER BY created_at DESC LIMIT ? OFFSET ?';
    queryParams.push(options.limit, options.offset);
    
    return await db.query(query, queryParams);
  },

  /**
   * Get unread notifications count
   * @param {number} userId - User ID
   * @returns {number} - Count of unread notifications
   */

  // notificationModel.js (continuation)
  /**
   * Get unread notifications count
   * @param {number} userId - User ID
   * @returns {number} - Count of unread notifications
   */
  async getUnreadCount(userId) {
    const [result] = await db.query(
      `SELECT COUNT(*) as count FROM notifications WHERE user_id = ? AND read_status = FALSE`,
      [userId]
    );
    
    return result.count;
  },

  /**
   * Create event notification for multiple users
   * @param {number} eventId - Event ID
   * @param {Array} userIds - Array of user IDs
   * @param {string} content - Notification content
   * @returns {number} - Number of notifications created
   */
  async createEventNotifications(eventId, userIds, content) {
    if (!userIds || userIds.length === 0) {
      return 0;
    }
    
    const values = userIds.map(userId => [userId, content, 'event', eventId]);
    
    const result = await db.query(
      `INSERT INTO notifications (user_id, content, type, related_id) VALUES ?`,
      [values]
    );
    
    return result.affectedRows;
  },

  /**
   * Create system notification for all users
   * @param {string} content - Notification content
   * @returns {number} - Number of notifications created
   */
  async createSystemNotificationForAll(content) {
    // Get all user IDs
    const users = await db.query('SELECT id FROM users');
    const userIds = users.map(user => user.id);
    
    if (userIds.length === 0) {
      return 0;
    }
    
    const values = userIds.map(userId => [userId, content, 'system', null]);
    
    const result = await db.query(
      `INSERT INTO notifications (user_id, content, type, related_id) VALUES ?`,
      [values]
    );
    
    return result.affectedRows;
  },

  /**
   * Delete old notifications
   * @param {number} days - Days to keep
   * @returns {number} - Number of notifications deleted
   */
  async deleteOldNotifications(days = 30) {
    const result = await db.query(
      `DELETE FROM notifications WHERE created_at < DATE_SUB(NOW(), INTERVAL ? DAY)`,
      [days]
    );
    
    return result.affectedRows;
  }
};

module.exports = Notification;
</file>

<file path="backend/api/models/recommendationModel.js">
// recommendationModel.js
const db = require('../../config/database');

/**
 * Recommendation model
 */
const Recommendation = {
  /**
   * Create or update a recommendation
   * @param {Object} recommendationData - Recommendation data
   * @returns {Object} - Created/updated recommendation object
   */
  async createOrUpdate(recommendationData) {
    try {
      // Check if recommendation already exists
      const [existingRecommendation] = await db.query(
        `SELECT id FROM recommendations WHERE user_id = ? AND event_id = ?`,
        [recommendationData.user_id, recommendationData.event_id]
      );

      let result;
      
      if (existingRecommendation) {
        // Update existing recommendation
        result = await db.query(
          `UPDATE recommendations SET score = ?, reason = ? WHERE id = ?`,
          [
            recommendationData.score,
            recommendationData.reason || null,
            existingRecommendation.id
          ]
        );
        
        // Get the updated recommendation
        const [updatedRecommendation] = await this.findById(existingRecommendation.id);
        return updatedRecommendation;
      } else {
        // Insert new recommendation
        result = await db.query(
          `INSERT INTO recommendations (user_id, event_id, score, reason) VALUES (?, ?, ?, ?)`,
          [
            recommendationData.user_id,
            recommendationData.event_id,
            recommendationData.score,
            recommendationData.reason || null
          ]
        );
        
        // Get the created recommendation
        const [newRecommendation] = await this.findById(result.insertId);
        return newRecommendation;
      }
    } catch (error) {
      throw error;
    }
  },

  /**
   * Find recommendation by ID
   * @param {number} id - Recommendation ID
   * @returns {Object} - Recommendation object
   */
  async findById(id) {
    return await db.query(
      `SELECT r.*, e.title as event_title, e.date as event_date
       FROM recommendations r
       JOIN events e ON r.event_id = e.id
       WHERE r.id = ?`,
      [id]
    );
  },

  /**
   * Delete recommendation
   * @param {number} id - Recommendation ID
   * @returns {boolean} - Success status
   */
  async delete(id) {
    const result = await db.query('DELETE FROM recommendations WHERE id = ?', [id]);
    return result.affectedRows > 0;
  },

  /**
   * Get user recommendations
   * @param {number} userId - User ID
   * @param {Object} options - Query options (limit, offset)
   * @returns {Array} - Array of recommendation objects
   */
  async getUserRecommendations(userId, options = { limit: 10, offset: 0 }) {
    return await db.query(
      `SELECT r.*, e.title, e.description, e.date, e.time, e.location, e.status, e.image
       FROM recommendations r
       JOIN events e ON r.event_id = e.id
       WHERE r.user_id = ? AND e.date >= CURDATE() AND e.status = 'upcoming'
       ORDER BY r.score DESC, e.date ASC
       LIMIT ? OFFSET ?`,
      [userId, options.limit, options.offset]
    );
  },

  /**
   * Generate recommendations for user
   * @param {number} userId - User ID
   * @returns {Array} - Array of recommendation objects
   * 
   * Note: This function would typically call an AI service or algorithm
   * to generate personalized recommendations. This implementation is a placeholder
   * that uses simple logic to recommend events.
   */
  async generateForUser(userId) {
    try {
      // Get user's past reviews and attended events
      const userReviews = await db.query(
        `SELECT r.event_id, r.rating, e.title, c.id as category_id
         FROM reviews r
         JOIN events e ON r.event_id = e.id
         JOIN event_categories ec ON e.id = ec.event_id
         JOIN categories c ON ec.category_id = c.id
         WHERE r.user_id = ?`,
        [userId]
      );
      
      // Get user's calendar events
      const userCalendar = await db.query(
        `SELECT c.event_id, e.title, ec.category_id
         FROM calendars c
         JOIN events e ON c.event_id = e.id
         JOIN event_categories ec ON e.id = ec.event_id
         WHERE c.user_id = ?`,
        [userId]
      );
      
      // Find categories the user is interested in
      const categoryInterest = {};
      
      userReviews.forEach(review => {
        if (!categoryInterest[review.category_id]) {
          categoryInterest[review.category_id] = 0;
        }
        categoryInterest[review.category_id] += review.rating;
      });
      
      userCalendar.forEach(event => {
        if (!categoryInterest[event.category_id]) {
          categoryInterest[event.category_id] = 0;
        }
        categoryInterest[event.category_id] += 3; // Attending an event shows interest
      });
      
      // Get upcoming events not already in user's calendar
      const upcomingEvents = await db.query(
        `SELECT e.id, e.title, e.date, e.time, e.location, e.status, ec.category_id, 
                e.avg_rating, COUNT(r.id) as review_count
         FROM events e
         JOIN event_categories ec ON e.id = ec.event_id
         LEFT JOIN reviews r ON e.id = r.event_id
         WHERE e.date >= CURDATE() 
         AND e.status = 'upcoming'
         AND e.id NOT IN (
           SELECT event_id FROM calendars WHERE user_id = ?
         )
         GROUP BY e.id, ec.category_id`,
        [userId]
      );
      
      // Score each event for the user
      const scoredEvents = {};
      
      upcomingEvents.forEach(event => {
        if (!scoredEvents[event.id]) {
          scoredEvents[event.id] = {
            event_id: event.id,
            title: event.title,
            score: 0,
            categories: []
          };
        }
        
        // Base score on category interest
        const categoryScore = categoryInterest[event.category_id] || 0;
        scoredEvents[event.id].score += categoryScore * 0.2;
        
        // Add category info
        scoredEvents[event.id].categories.push(event.category_id);
        
        // Factor in event popularity (review count and rating)
        scoredEvents[event.id].score += (event.avg_rating * 0.5) + (Math.min(event.review_count, 10) * 0.03);
      });
      
      // Convert to array and sort by score
      const recommendations = Object.values(scoredEvents)
        .map(item => ({
          user_id: userId,
          event_id: item.event_id,
          score: parseFloat(item.score.toFixed(4)),
          reason: `Based on your interest in events like "${item.title}"`
        }))
        .filter(item => item.score > 0)
        .sort((a, b) => b.score - a.score);
      
      // Save recommendations to database
      const savedRecommendations = [];
      
      for (const rec of recommendations.slice(0, 20)) { // Limit to top 20
        const saved = await this.createOrUpdate(rec);
        savedRecommendations.push(saved);
      }
      
      return savedRecommendations;
    } catch (error) {
      throw error;
    }
  },

  /**
   * Get popular events
   * @param {Object} options - Query options (limit, categoryId)
   * @returns {Array} - Array of popular event objects
   */
  async getPopularEvents(options = { limit: 10, categoryId: null }) {
    let query = `
      SELECT e.id, e.title, e.description, e.date, e.time, e.location, 
             e.image, e.avg_rating, COUNT(r.id) as review_count,
             COUNT(c.id) as calendar_count
      FROM events e
      LEFT JOIN reviews r ON e.id = r.event_id
      LEFT JOIN calendars c ON e.id = c.event_id
    `;
    
    const queryParams = [];
    
    if (options.categoryId) {
      query += `
        JOIN event_categories ec ON e.id = ec.event_id
        WHERE ec.category_id = ? AND e.date >= CURDATE() AND e.status = 'upcoming'
      `;
      queryParams.push(options.categoryId);
    } else {
      query += `
        WHERE e.date >= CURDATE() AND e.status = 'upcoming'
      `;
    }
    
    query += `
      GROUP BY e.id
      ORDER BY (e.avg_rating * 0.5) + (calendar_count * 0.3) + (review_count * 0.2) DESC
      LIMIT ?
    `;
    queryParams.push(options.limit);
    
    return await db.query(query, queryParams);
  },

  /**
   * Delete old recommendations
   * @param {number} days - Days to keep
   * @returns {number} - Number of recommendations deleted
   */
  async deleteOldRecommendations(days = 7) {
    const result = await db.query(
      `DELETE FROM recommendations WHERE created_at < DATE_SUB(NOW(), INTERVAL ? DAY)`,
      [days]
    );
    
    return result.affectedRows;
  }
};

module.exports = Recommendation;
</file>

<file path="backend/api/models/reviewModel.js">
// reviewModel.js
const db = require('../../config/database');
const Event = require('./eventModel');

/**
 * Review model
 */
const Review = {
  /**
   * Create a new review
   * @param {Object} reviewData - Review data
   * @returns {Object} - Created review object
   */
  async create(reviewData) {
    try {
      // Calculate sentiment (this would be integrated with a sentiment analysis service)
      let sentimentScore = null;
      let sentimentCategory = null;
      
      // If you have a sentiment analysis service, you would call it here
      // For now, we'll just assign a random score as a placeholder
      if (reviewData.content) {
        sentimentScore = Math.random() * 2 - 1; // Random score between -1 and 1
        
        if (sentimentScore > 0.3) {
          sentimentCategory = 'positive';
        } else if (sentimentScore < -0.3) {
          sentimentCategory = 'negative';
        } else {
          sentimentCategory = 'neutral';
        }
      }

      // Insert review into database
      const result = await db.query(
        `INSERT INTO reviews (user_id, event_id, rating, content, sentiment_score, sentiment_category) 
         VALUES (?, ?, ?, ?, ?, ?)`,
        [
          reviewData.user_id,
          reviewData.event_id,
          reviewData.rating,
          reviewData.content,
          sentimentScore,
          sentimentCategory
        ]
      );

      // Update event rating
      await Event.updateRating(reviewData.event_id);

      // Get the created review
      const [review] = await this.findById(result.insertId);
      return review;
    } catch (error) {
      throw error;
    }
  },

  /**
   * Find review by ID
   * @param {number} id - Review ID
   * @returns {Object} - Review object
   */
  async findById(id) {
    return await db.query(
      `SELECT r.*, u.username as user_name, e.title as event_title FROM reviews r
       JOIN users u ON r.user_id = u.id
       JOIN events e ON r.event_id = e.id
       WHERE r.id = ?`,
      [id]
    );
  },

  /**
   * Update review
   * @param {number} id - Review ID
   * @param {Object} reviewData - Review data to update
   * @returns {Object} - Updated review object
   */
  async update(id, reviewData) {
    // Get the current review to get the event_id
    const [currentReview] = await this.findById(id);
    if (!currentReview) {
      throw new Error('Review not found');
    }

    // Create dynamic update query based on provided fields
    const fields = [];
    const values = [];

    if (reviewData.rating) {
      fields.push('rating = ?');
      values.push(reviewData.rating);
    }
    
    if (reviewData.content) {
      fields.push('content = ?');
      values.push(reviewData.content);
      
      // Recalculate sentiment (this would be integrated with a sentiment analysis service)
      let sentimentScore = Math.random() * 2 - 1; // Random score between -1 and 1
      let sentimentCategory;
      
      if (sentimentScore > 0.3) {
        sentimentCategory = 'positive';
      } else if (sentimentScore < -0.3) {
        sentimentCategory = 'negative';
      } else {
        sentimentCategory = 'neutral';
      }
      
      fields.push('sentiment_score = ?');
      values.push(sentimentScore);
      fields.push('sentiment_category = ?');
      values.push(sentimentCategory);
    }

    // Only proceed if there are fields to update
    if (fields.length === 0) {
      return await this.findById(id);
    }

    // Add ID to values array
    values.push(id);

    // Execute update query
    await db.query(
      `UPDATE reviews SET ${fields.join(', ')} WHERE id = ?`,
      values
    );

    // Update event rating
    await Event.updateRating(currentReview.event_id);

    // Return updated review
    const [updatedReview] = await this.findById(id);
    return updatedReview;
  },

  /**
   * Delete review
   * @param {number} id - Review ID
   * @returns {boolean} - Success status
   */
  async delete(id) {
    // Get the current review to get the event_id
    const [currentReview] = await this.findById(id);
    if (!currentReview) {
      return false;
    }

    const result = await db.query('DELETE FROM reviews WHERE id = ?', [id]);
    
    // Update event rating
    if (result.affectedRows > 0) {
      await Event.updateRating(currentReview.event_id);
      return true;
    }
    
    return false;
  },

  /**
   * Get reviews by event
   * @param {number} eventId - Event ID
   * @param {Object} options - Query options (limit, offset)
   * @returns {Array} - Array of review objects
   */
  async getByEvent(eventId, options = { limit: 10, offset: 0 }) {
    return await db.query(
      `SELECT r.*, u.username as user_name FROM reviews r
       JOIN users u ON r.user_id = u.id
       WHERE r.event_id = ?
       ORDER BY r.created_at DESC
       LIMIT ? OFFSET ?`,
      [eventId, options.limit, options.offset]
    );
  },

  /**
   * Get reviews by user
   * @param {number} userId - User ID
   * @param {Object} options - Query options (limit, offset)
   * @returns {Array} - Array of review objects
   */
  async getByUser(userId, options = { limit: 10, offset: 0 }) {
    return await db.query(
      `SELECT r.*, e.title as event_title FROM reviews r
       JOIN events e ON r.event_id = e.id
       WHERE r.user_id = ?
       ORDER BY r.created_at DESC
       LIMIT ? OFFSET ?`,
      [userId, options.limit, options.offset]
    );
  },

  /**
   * Get review statistics
   * @param {number} eventId - Event ID
   * @returns {Object} - Review statistics
   */
  async getStats(eventId) {
    const [stats] = await db.query(
      `SELECT 
        COUNT(*) as total_reviews,
        AVG(rating) as avg_rating,
        SUM(CASE WHEN rating = 5 THEN 1 ELSE 0 END) as five_star,
        SUM(CASE WHEN rating = 4 THEN 1 ELSE 0 END) as four_star,
        SUM(CASE WHEN rating = 3 THEN 1 ELSE 0 END) as three_star,
        SUM(CASE WHEN rating = 2 THEN 1 ELSE 0 END) as two_star,
        SUM(CASE WHEN rating = 1 THEN 1 ELSE 0 END) as one_star,
        SUM(CASE WHEN sentiment_category = 'positive' THEN 1 ELSE 0 END) as positive_reviews,
        SUM(CASE WHEN sentiment_category = 'neutral' THEN 1 ELSE 0 END) as neutral_reviews,
        SUM(CASE WHEN sentiment_category = 'negative' THEN 1 ELSE 0 END) as negative_reviews
      FROM reviews
      WHERE event_id = ?`,
      [eventId]
    );
    
    return stats;
  }
};

module.exports = Review;
</file>

<file path="backend/api/models/userModel.js">
const db = require('../../config/database');
const bcrypt = require('bcryptjs');

/**
 * User model
 */
const User = {
  /**
   * Create a new user
   * @param {Object} userData - User data
   * @returns {Object} - Created user object
   */
  async create(userData) {
    try {
      // Hash password
      const salt = await bcrypt.genSalt(10);
      const hashedPassword = await bcrypt.hash(userData.password, salt);

      // Insert user into database
      const result = await db.query(
        `INSERT INTO users (username, email, password, bio, profile_pic) VALUES (?, ?, ?, ?, ?)`,
        [
          userData.username,
          userData.email,
          hashedPassword,
          userData.bio || null,
          userData.profile_pic || null
        ]
      );

      // Get the created user
      const [user] = await this.findById(result.insertId);
      return user;
    } catch (error) {
      throw error;
    }
  },

  /**
   * Find user by ID
   * @param {number} id - User ID
   * @returns {Array} - User object array
   */
  async findById(id) {
    return await db.query(
      `SELECT id, username, email, bio, profile_pic, is_admin, created_at, updated_at FROM users WHERE id = ?`,
      [id]
    );
  },

  /**
   * Find user by email (includes password for authentication)
   * @param {string} email - User email
   * @returns {Array} - User object array with password
   */
  async findByEmail(email) {
    return await db.query(
      `SELECT id, username, email, password, bio, profile_pic, is_admin, created_at, updated_at FROM users WHERE email = ?`,
      [email]
    );
  },

  /**
   * Find user by username
   * @param {string} username - Username
   * @returns {Array} - User object array
   */
  async findByUsername(username) {
    return await db.query(
      `SELECT id, username, email, bio, profile_pic, is_admin, created_at, updated_at FROM users WHERE username = ?`,
      [username]
    );
  },

  /**
   * Update user profile
   * @param {number} id - User ID
   * @param {Object} userData - User data to update
   * @returns {Object} - Updated user object
   */
  async update(id, userData) {
    // Create dynamic update query based on provided fields
    const fields = [];
    const values = [];

    if (userData.username) {
      fields.push('username = ?');
      values.push(userData.username);
    }
    if (userData.email) {
      fields.push('email = ?');
      values.push(userData.email);
    }
    if (userData.bio) {
      fields.push('bio = ?');
      values.push(userData.bio);
    }
    if (userData.profile_pic) {
      fields.push('profile_pic = ?');
      values.push(userData.profile_pic);
    }
    if (userData.password) {
      const salt = await bcrypt.genSalt(10);
      const hashedPassword = await bcrypt.hash(userData.password, salt);
      fields.push('password = ?');
      values.push(hashedPassword);
    }

    // Only proceed if there are fields to update
    if (fields.length === 0) {
      return await this.findById(id);
    }

    // Add ID to values array
    values.push(id);

    // Execute update query
    await db.query(
      `UPDATE users SET ${fields.join(', ')} WHERE id = ?`,
      values
    );

    // Return updated user
    const [updatedUser] = await this.findById(id);
    return updatedUser;
  },

  /**
   * Delete user
   * @param {number} id - User ID
   * @returns {boolean} - Success status
   */
  async delete(id) {
    const result = await db.query('DELETE FROM users WHERE id = ?', [id]);
    return result.affectedRows > 0;
  },

  /**
   * Get all users
   * @param {Object} options - Query options (limit, offset)
   * @returns {Array} - Array of user objects
   */
  async getAll(options = { limit: 10, offset: 0 }) {
    return await db.query(
      `SELECT id, username, email, bio, profile_pic, is_admin, created_at, updated_at 
       FROM users 
       ORDER BY created_at DESC 
       LIMIT ? OFFSET ?`,
      [options.limit, options.offset]
    );
  },

  /**
   * Change user role (admin/non-admin)
   * @param {number} id - User ID
   * @param {boolean} isAdmin - Admin status
   * @returns {Object} - Updated user object
   */
  async changeRole(id, isAdmin) {
    await db.query('UPDATE users SET is_admin = ? WHERE id = ?', [isAdmin, id]);
    const [updatedUser] = await this.findById(id);
    return updatedUser;
  },

  /**
   * Verify user password
   * @param {string} password - Plain password
   * @param {string} hashedPassword - Hashed password from database
   * @returns {boolean} - Password match status
   */
  async verifyPassword(password, hashedPassword) {
    return await bcrypt.compare(password, hashedPassword);
  },

  /**
   * Get user events
   * @param {number} userId - User ID
   * @param {string} type - Event type (organized, attended)
   * @returns {Array} - Array of event objects
   */
  async getUserEvents(userId, type = 'organized') {
    if (type === 'organized') {
      return await db.query(
        `SELECT e.* FROM events e
         WHERE e.organizer_id = ?
         ORDER BY e.date DESC`,
        [userId]
      );
    } else {
      return await db.query(
        `SELECT e.* FROM events e
         JOIN calendars c ON e.id = c.event_id
         WHERE c.user_id = ?
         ORDER BY e.date DESC`,
        [userId]
      );
    }
  },

  /**
   * Get user reviews
   * @param {number} userId - User ID
   * @returns {Array} - Array of review objects
   */
  async getUserReviews(userId) {
    return await db.query(
      `SELECT r.*, e.title as event_title FROM reviews r
       JOIN events e ON r.event_id = e.id
       WHERE r.user_id = ?
       ORDER BY r.created_at DESC`,
      [userId]
    );
  },

  /**
   * Count users
   * @returns {number} - Total number of users
   */
  async count() {
    const [result] = await db.query('SELECT COUNT(*) as total FROM users');
    return result.total;
  }
};

module.exports = User;
</file>

<file path="backend/config/config.js">
const dotenv = require('dotenv');

dotenv.config();

const config = {
  app: {
    port: process.env.PORT || 3000,
    env: process.env.NODE_ENV || 'development',
    jwtSecret: process.env.JWT_SECRET || '3d6f1a7e9c4b1e6e9f1a2c5b7d8e3a9f1c4b6d7e9f1a3b5c6d7e8f9a2b3c4d6',
    jwtExpiresIn: process.env.JWT_EXPIRES_IN || '24h'
  },
  db: {
    host: process.env.DB_HOST || 'localhost',
    user: process.env.DB_USER || 'root',
    password: process.env.DB_PASS || '',
    database: process.env.DB_NAME || 'eventreviews'
  },
  claude: {
    apiKey: process.env.CLAUDE_API_KEY,
    apiUrl: process.env.CLAUDE_API_URL || 'https://api.anthropic.com/v1/messages'
  },
  upload: {
    path: process.env.UPLOAD_PATH || './uploads',
    maxFileSize: parseInt(process.env.MAX_FILE_SIZE) || 5 * 1024 * 1024 // 5MB
  },
  email: {
    host: process.env.EMAIL_HOST,
    port: parseInt(process.env.EMAIL_PORT) || 587,
    user: process.env.EMAIL_USER,
    pass: process.env.EMAIL_PASS
  }
};

module.exports = config;
</file>

<file path="backend/config/database.js">
const mysql = require('mysql2/promise');
const dotenv = require('dotenv');
const { logger } = require('../utils/logger');

dotenv.config();

// Database connection pool configuration
const pool = mysql.createPool({
  host: process.env.DB_HOST || 'localhost',
  user: process.env.DB_USER || 'root',
  password: process.env.DB_PASS || '',
  database: process.env.DB_NAME || 'eventreviews',
  waitForConnections: true,
  connectionLimit: 10,
  queueLimit: 0
});

// Test database connection
async function testConnection() {
  try {
    const connection = await pool.getConnection();
    logger.info('Database connection established successfully');
    connection.release();
    return true;
  } catch (err) {
    logger.error(`Database connection failed: ${err.message}`);
    console.error('Database connection failed:', err);
    return false;
  }
}

// Initialize connection
testConnection();

module.exports = {
  pool,
  query: async (sql, params) => {
    try {
      const [results] = await pool.execute(sql, params);
      return results;
    } catch (error) {
      logger.error(`DB Query Error: ${error.message}`);
      throw error;
    }
  }
};
</file>

<file path="backend/server.js">
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const morgan = require('morgan');
const path = require('path');
const dotenv = require('dotenv');
const { logger } = require('./utils/logger');
const errorHandler = require('./api/middleware/errorHandler');

// Load environment variables
dotenv.config();

// Initialize express app
const app = express();
const PORT = process.env.PORT || 3000;

// Database connection
const dbConnection = require('./config/database');

// Middleware
app.use(helmet()); // Security headers
app.use(cors()); // Enable CORS
app.use(express.json()); // Parse JSON bodies
app.use(express.urlencoded({ extended: true })); // Parse URL-encoded bodies
app.use(morgan('dev')); // HTTP request logger

// Static files
app.use('/uploads', express.static(path.join(__dirname, 'uploads')));

// Routes
app.use('/api/users', require('./api/routes/users'));
app.use('/api/events', require('./api/routes/events'));
app.use('/api/reviews', require('./api/routes/reviews'));
app.use('/api/categories', require('./api/routes/categories'));
app.use('/api/calendar', require('./api/routes/calendar'));
app.use('/api/notifications', require('./api/routes/notifications'));
app.use('/api/recommendations', require('./api/routes/recommendations'));

// Root route
app.get('/', (req, res) => {
  res.json({ message: 'Welcome to the Event Reviews API' });
});

// Error handling middleware
app.use(errorHandler);

// Start the server
app.listen(PORT, () => {
  logger.info(`Server running on port ${PORT}`);
  console.log(`Server running on port ${PORT}`);
});

// Handle unhandled promise rejections
process.on('unhandledRejection', (err) => {
  logger.error(`Unhandled Rejection: ${err.message}`);
  console.error('Unhandled Rejection:', err);
  // Close server & exit process
  // server.close(() => process.exit(1));
});

module.exports = app; // For testing
</file>

<file path="backend/service/ai.service.js">
const axios = require('axios');
const dotenv = require('dotenv');

dotenv.config();

// Claude AI API configuration
const CLAUDE_API_KEY = process.env.CLAUDE_API_KEY;
const CLAUDE_API_URL = process.env.CLAUDE_API_URL || 'https://api.anthropic.com/v1/messages';

/**
 * Analyzes the sentiment of a review text using Claude AI
 * @param {string} text - The review text to analyze
 * @returns {Object} - Sentiment score and category
 */
exports.analyzeSentiment = async (text) => {
  try {
    // Simple fallback if API key not configured
    if (!CLAUDE_API_KEY) {
      console.warn('Claude API key not configured. Using fallback sentiment analysis.');
      return fallbackSentimentAnalysis(text);
    }
    
    const response = await axios.post(
      CLAUDE_API_URL,
      {
        model: "claude-3-haiku-20240307",
        max_tokens: 100,
        messages: [
          {
            role: "user",
            content: `Analyze the sentiment of this event review. Return only a JSON object with a 'score' (number between 0 and 1, where 0 is very negative and 1 is very positive) and a 'category' (one of: 'positive', 'neutral', 'negative').
            
            Review: "${text}"
            
            Response format:
            {
              "score": 0.XX,
              "category": "positive|neutral|negative"
            }`
          }
        ]
      },
      {
        headers: {
          'Content-Type': 'application/json',
          'x-api-key': CLAUDE_API_KEY,
          'anthropic-version': '2023-06-01'
        }
      }
    );
    
    // Extract the JSON from Claude's response
    const content = response.data.content[0].text;
    
    // Parse the JSON response
    try {
      const parsedResult = JSON.parse(content);
      return {
        score: parsedResult.score,
        category: parsedResult.category
      };
    } catch (parseError) {
      console.error('Failed to parse Claude AI response:', parseError);
      return fallbackSentimentAnalysis(text);
    }
  } catch (error) {
    console.error('Claude API error:', error.response?.data || error.message);
    return fallbackSentimentAnalysis(text);
  }
};

/**
 * Simple fallback sentiment analysis for when API is not available
 * @param {string} text - The review text to analyze
 * @returns {Object} - Sentiment score and category
 */
function fallbackSentimentAnalysis(text) {
  const lowercaseText = text.toLowerCase();
  
  // Simple keyword-based sentiment analysis
  const positiveWords = ['great', 'amazing', 'excellent', 'good', 'love', 'best', 'awesome', 'enjoyed', 'recommend', 'fantastic', 'wonderful'];
  const negativeWords = ['bad', 'terrible', 'awful', 'poor', 'hate', 'worst', 'disappointed', 'waste', 'horrible', 'avoid'];
  
  let positiveCount = 0;
  let negativeCount = 0;
  
  // Count positive and negative keywords
  positiveWords.forEach(word => {
    const regex = new RegExp(`\\b${word}\\b`, 'gi');
    const matches = lowercaseText.match(regex);
    if (matches) {
      positiveCount += matches.length;
    }
  });
  
  negativeWords.forEach(word => {
    const regex = new RegExp(`\\b${word}\\b`, 'gi');
    const matches = lowercaseText.match(regex);
    if (matches) {
      negativeCount += matches.length;
    }
  });
  
  const totalWordCount = text.split(/\s+/).length;
  let score;
  let category;
  
  if (positiveCount > negativeCount) {
    // More positive words than negative
    score = 0.5 + (0.5 * (positiveCount / (positiveCount + negativeCount + 1)));
    category = 'positive';
  } else if (negativeCount > positiveCount) {
    // More negative words than positive
    score = 0.5 - (0.5 * (negativeCount / (positiveCount + negativeCount + 1)));
    category = 'negative';
  } else {
    // Equal or no sentiment words
    score = 0.5;
    category = 'neutral';
  }
  
  return { score, category };
}

/**
 * Generates review summaries for events
 * @param {Array} reviews - Array of review objects
 * @returns {Object} - Summary insights
 */
exports.generateReviewSummary = async (reviews) => {
  try {
    if (!CLAUDE_API_KEY || reviews.length === 0) {
      return {
        averageRating: 0,
        sentimentBreakdown: {
          positive: 0,
          neutral: 0,
          negative: 0
        },
        summary: "No reviews available for summarization"
      };
    }

    // Extract review texts to analyze
    const reviewsText = reviews.map(review => {
      return `Rating: ${review.rating}/5\nReview: ${review.content}`;
    }).join("\n\n");

    // Calculate average rating
    const averageRating = reviews.reduce((sum, review) => sum + review.rating, 0) / reviews.length;

    // Get sentiment breakdown
    const sentimentBreakdown = {
      positive: reviews.filter(r => r.sentiment_category === 'positive').length,
      neutral: reviews.filter(r => r.sentiment_category === 'neutral').length,
      negative: reviews.filter(r => r.sentiment_category === 'negative').length
    };

    // Generate summary using Claude
    const response = await axios.post(
      CLAUDE_API_URL,
      {
        model: "claude-3-haiku-20240307",
        max_tokens: 300,
        messages: [
          {
            role: "user",
            content: `Analyze the following event reviews and provide a concise summary of common themes, standout positive points, and areas for improvement:

            ${reviewsText}
            
            Format your response as a simple paragraph without using any special formatting or symbols.`
          }
        ]
      },
      {
        headers: {
          'Content-Type': 'application/json',
          'x-api-key': CLAUDE_API_KEY,
          'anthropic-version': '2023-06-01'
        }
      }
    );

    // Extract the summary text
    const summaryText = response.data.content[0].text.trim();

    return {
      averageRating,
      sentimentBreakdown,
      summary: summaryText
    };
  } catch (error) {
    console.error('Error generating review summary:', error.response?.data || error.message);
    
    // Fallback summary if API fails
    const averageRating = reviews.length > 0 
      ? reviews.reduce((sum, review) => sum + review.rating, 0) / reviews.length 
      : 0;

    const sentimentBreakdown = {
      positive: reviews.filter(r => r.sentiment_category === 'positive').length,
      neutral: reviews.filter(r => r.sentiment_category === 'neutral').length,
      negative: reviews.filter(r => r.sentiment_category === 'negative').length
    };

    return {
      averageRating,
      sentimentBreakdown,
      summary: "Unable to generate detailed summary. Please check the system logs for more information."
    };
  }
};

/**
 * Generates personalized event recommendations for users
 * @param {Object} user - User object
 * @param {Array} events - Available events
 * @param {Array} userReviews - User's past reviews
 * @returns {Array} - Recommended events with scores and reasons
 */
exports.generateRecommendations = async (user, events, userReviews) => {
  try {
    if (!CLAUDE_API_KEY || events.length === 0) {
      return generateFallbackRecommendations(user, events, userReviews);
    }

    // Get user preferences based on past reviews and behavior
    const userPreferences = analyzeUserPreferences(userReviews);
    
    // Generate recommendations for each event
    const recommendations = [];
    
    for (const event of events) {
      // Calculate compatibility score between user and event
      const score = calculateCompatibilityScore(event, userPreferences);
      
      // Generate reason for recommendation
      const reason = generateRecommendationReason(event, userPreferences, score);
      
      recommendations.push({
        eventId: event.id,
        userId: user.id,
        score,
        reason
      });
    }
    
    // Sort by score (highest first) and return top recommendations
    return recommendations
      .sort((a, b) => b.score - a.score)
      .slice(0, 5); // Return top 5 recommendations
  } catch (error) {
    console.error('Error generating recommendations:', error);
    return generateFallbackRecommendations(user, events, userReviews);
  }
};

/**
 * Analyzes user preferences based on reviews
 * @param {Array} userReviews - User's past reviews
 * @returns {Object} - User preferences
 */
function analyzeUserPreferences(userReviews) {
  // Default preferences
  const preferences = {
    categories: {},
    avgRating: 0,
    positiveKeywords: [],
    negativeKeywords: []
  };
  
  if (!userReviews || userReviews.length === 0) {
    return preferences;
  }
  
  // Extract category preferences
  userReviews.forEach(review => {
    if (review.event && review.event.categories) {
      review.event.categories.forEach(category => {
        if (!preferences.categories[category.id]) {
          preferences.categories[category.id] = {
            count: 0,
            avgRating: 0
          };
        }
        
        preferences.categories[category.id].count++;
        preferences.categories[category.id].avgRating += review.rating;
      });
    }
  });
  
  // Calculate average rating per category
  Object.keys(preferences.categories).forEach(categoryId => {
    const category = preferences.categories[categoryId];
    category.avgRating = category.avgRating / category.count;
  });
  
  // Calculate overall average rating
  preferences.avgRating = userReviews.reduce((sum, review) => sum + review.rating, 0) / userReviews.length;
  
  // Extract keywords from reviews
  const allReviewText = userReviews.map(review => review.content).join(' ').toLowerCase();
  
  // Simple keyword extraction (can be improved)
  const positiveKeywords = ['great', 'amazing', 'excellent', 'good', 'love', 'best', 'awesome', 'enjoyed'];
  const negativeKeywords = ['bad', 'terrible', 'awful', 'poor', 'hate', 'worst', 'disappointed'];
  
  preferences.positiveKeywords = positiveKeywords.filter(word => allReviewText.includes(word));
  preferences.negativeKeywords = negativeKeywords.filter(word => allReviewText.includes(word));
  
  return preferences;
}

/**
 * Calculates compatibility score between event and user preferences
 * @param {Object} event - Event object
 * @param {Object} preferences - User preferences
 * @returns {Number} - Compatibility score (0-1)
 */
function calculateCompatibilityScore(event, preferences) {
  let score = 0.5; // Default neutral score
  
  // Category match
  let categoryScore = 0;
  if (event.categories && event.categories.length > 0) {
    event.categories.forEach(category => {
      if (preferences.categories[category.id]) {
        const catPref = preferences.categories[category.id];
        categoryScore += (catPref.avgRating / 5) * (catPref.count / 10);
      }
    });
    
    categoryScore = Math.min(categoryScore, 1) / event.categories.length;
    score += categoryScore * 0.4; // Category match is 40% of total score
  }
  
  // Rating match (how close is the event rating to user's average preferred rating)
  const ratingDiff = Math.abs(event.avg_rating - preferences.avgRating);
  const ratingScore = 1 - (ratingDiff / 5);
  score += ratingScore * 0.3; // Rating match is 30% of total score
  
  // Keyword match in event description
  const eventText = (event.title + ' ' + event.description).toLowerCase();
  let keywordScore = 0;
  
  preferences.positiveKeywords.forEach(keyword => {
    if (eventText.includes(keyword)) {
      keywordScore += 0.1;
    }
  });
  
  preferences.negativeKeywords.forEach(keyword => {
    if (eventText.includes(keyword)) {
      keywordScore -= 0.1;
    }
  });
  
  keywordScore = Math.max(-1, Math.min(1, keywordScore));
  score += (keywordScore + 1) / 2 * 0.3; // Normalize to 0-1 and account for 30% of score
  
  // Ensure score is between 0 and 1
  return Math.max(0, Math.min(1, score));
}

/**
 * Generates a reason for recommending an event
 * @param {Object} event - Event object
 * @param {Object} preferences - User preferences
 * @param {Number} score - Compatibility score
 * @returns {String} - Recommendation reason
 */
function generateRecommendationReason(event, preferences, score) {
  // Default reasons based on score ranges
  if (score > 0.8) {
    return `Highly matches your interests based on your ratings and reviews`;
  } else if (score > 0.6) {
    return `Similar to events you've enjoyed in the past`;
  } else if (score > 0.4) {
    return `You might find this event interesting`;
  } else {
    return `This event offers something different from your usual preferences`;
  }
}

/**
 * Generates fallback recommendations when AI API is not available
 * @param {Object} user - User object
 * @param {Array} events - Available events
 * @param {Array} userReviews - User's past reviews
 * @returns {Array} - Basic recommended events
 */
function generateFallbackRecommendations(user, events, userReviews) {
  // Simple recommendation logic: sort by highest rated events
  return events
    .slice(0, 10)
    .map(event => ({
      eventId: event.id,
      userId: user.id,
      score: event.avg_rating / 5, // Normalize to 0-1
      reason: "Based on event popularity and rating"
    }))
    .sort((a, b) => b.score - a.score)
    .slice(0, 5); // Return top 5
}

/**
 * Updates the database with sentiment analysis results
 * @param {Object} db - Database connection
 * @param {number} reviewId - Review ID
 * @param {Object} sentiment - Sentiment analysis results
 * @returns {boolean} - Success status
 */
exports.updateReviewSentiment = async (db, reviewId, sentiment) => {
  try {
    await db.query(
      'UPDATE reviews SET sentiment_score = ?, sentiment_category = ?, updated_at = NOW() WHERE id = ?',
      [sentiment.score, sentiment.category, reviewId]
    );
    
    console.log(`Updated sentiment for review #${reviewId}: ${sentiment.category} (${sentiment.score})`);
    return true;
  } catch (error) {
    console.error(`Failed to update sentiment for review #${reviewId}:`, error);
    return false;
  }
};

/**
 * Processes batch sentiment analysis for multiple reviews
 * @param {Object} db - Database connection
 * @param {Array} reviews - Array of review objects
 * @returns {Object} - Processing results with success count
 */
exports.processBatchSentimentAnalysis = async (db, reviews) => {
  const results = {
    total: reviews.length,
    success: 0,
    failed: 0,
    details: []
  };
  
  for (const review of reviews) {
    try {
      // Skip reviews that already have sentiment analysis
      if (review.sentiment_score !== null && review.sentiment_category !== null) {
        results.details.push({
          reviewId: review.id,
          status: 'skipped',
          message: 'Sentiment already analyzed'
        });
        continue;
      }
      
      // Analyze sentiment
      const sentiment = await exports.analyzeSentiment(review.content);
      
      // Update database
      const success = await exports.updateReviewSentiment(db, review.id, sentiment);
      
      if (success) {
        results.success++;
        results.details.push({
          reviewId: review.id,
          status: 'success',
          sentiment
        });
      } else {
        results.failed++;
        results.details.push({
          reviewId: review.id,
          status: 'failed',
          message: 'Database update failed'
        });
      }
    } catch (error) {
      results.failed++;
      results.details.push({
        reviewId: review.id,
        status: 'error',
        message: error.message
      });
    }
  }
  
  return results;
};
</file>

<file path="backend/utils/helpers.js">
/**
 * Collection of helper functions for the application
 */

/**
 * Formats a date to YYYY-MM-DD format
 * @param {Date} date - Date object
 * @returns {string} - Formatted date string
 */
const formatDate = (date) => {
    return date.toISOString().split('T')[0];
  };
  
  /**
   * Generates a random string for various purposes
   * @param {number} length - Length of the string
   * @returns {string} - Random string
   */
  const generateRandomString = (length = 10) => {
    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    let result = '';
    for (let i = 0; i < length; i++) {
      result += characters.charAt(Math.floor(Math.random() * characters.length));
    }
    return result;
  };
  
  /**
   * Paginates an array of results
   * @param {Array} array - The array to paginate
   * @param {number} page - The page number
   * @param {number} limit - Items per page
   * @returns {Object} - Paginated results
   */
  const paginate = (array, page = 1, limit = 10) => {
    const startIndex = (page - 1) * limit;
    const endIndex = page * limit;
    const results = {};
  
    if (endIndex < array.length) {
      results.next = {
        page: page + 1,
        limit
      };
    }
  
    if (startIndex > 0) {
      results.previous = {
        page: page - 1,
        limit
      };
    }
  
    results.totalPages = Math.ceil(array.length / limit);
    results.currentPage = page;
    results.totalItems = array.length;
    results.results = array.slice(startIndex, endIndex);
  
    return results;
  };
  
  /**
   * Validates if a string is a valid email
   * @param {string} email - Email to validate
   * @returns {boolean} - Is valid email
   */
  const isValidEmail = (email) => {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  };
  
  /**
   * Removes sensitive fields from user object
   * @param {Object} user - User object
   * @returns {Object} - Sanitized user object
   */
   const sanitizeUser = (user) => {
    if (!user) return null;
    
    const { password, ...sanitizedUser } = user;
    return sanitizedUser;
  };
  
  /**
   * Escapes special characters in strings for SQL queries
   * @param {string} text - Input text
   * @returns {string} - Escaped text
   */
  const escapeSQL = (text) => {
    if (typeof text !== 'string') return text;
    
    return text
      .replace(/\\/g, '\\\\')
      .replace(/'/g, "\\'")
      .replace(/"/g, '\\"')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/\t/g, '\\t')
      .replace(/\0/g, '\\0');
  };
  
  module.exports = {
    formatDate,
    generateRandomString,
    paginate,
    isValidEmail,
    sanitizeUser,
    escapeSQL
  };
</file>

<file path="backend/utils/logger.js">
const winston = require('winston');
const path = require('path');

// Define log format
const logFormat = winston.format.combine(
  winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
  winston.format.errors({ stack: true }),
  winston.format.splat(),
  winston.format.json()
);

// Create logger instance
const logger = winston.createLogger({
  level: process.env.NODE_ENV === 'production' ? 'info' : 'debug',
  format: logFormat,
  defaultMeta: { service: 'eventreviews-api' },
  transports: [
    // Write all logs with level 'error' and below to error.log
    new winston.transports.File({ 
      filename: path.join(__dirname, '../logs/error.log'), 
      level: 'error' 
    }),
    // Write all logs with level 'info' and below to combined.log
    new winston.transports.File({ 
      filename: path.join(__dirname, '../logs/combined.log') 
    })
  ]
});
</file>

<file path="README.md">
# review
</file>

<file path="backend/package.json">
{
  "name": "backend",
  "version": "1.0.0",
  "description": "",
  "main": "server.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "commonjs",
  "dependencies": {
    "axios": "^1.8.3",
    "bcryptjs": "^3.0.2",
    "compression": "^1.8.0",
    "cors": "^2.8.5",
    "dotenv": "^16.4.7",
    "express": "^4.21.2",
    "express-rate-limit": "^7.5.0",
    "express-validator": "^7.2.1",
    "helmet": "^8.0.0",
    "jsonwebtoken": "^9.0.2",
    "morgan": "^1.10.0",
    "multer": "^1.4.5-lts.1",
    "mysql2": "^3.13.0",
    "winston": "^3.17.0"
  }
}
</file>

</files>
